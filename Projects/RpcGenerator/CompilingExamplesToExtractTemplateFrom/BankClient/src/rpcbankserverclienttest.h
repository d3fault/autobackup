#ifndef RPCBANKSERVERCLIENTTEST_H
#define RPCBANKSERVERCLIENTTEST_H

#include <QObject>

#include "bankserverclientdebugwidget.h"
#include "bankserverclient.h"
#include "AutoGeneratedRpcBankServerClientCode/rpcbankserverhelper.h"
#include "objectonthreadhelper.h"

//TODOreq: this is really important:
//my client is expected to be in fully operational mode
//man i keep flip flopping on the issue
//and i think i've flip flopped before
//i don't know which or if it even matters
//i THINK it's better to have both the client and server be rpc generator independent.
//how do i marry the rpc-service-specific message dispensers that are passed in to my rpc server's backends? does that not make the class dependent on the rpc shit?
//can't a way be hacked so that the "rpc action request" and "do something on the action and return a result i guess somehow generically" be married together without depending on one another? I know this is possible but have yet to finalize/complete the hack in my head. It is only a matter of doing. Putting more thought into it at the relevant time. When that is who knows.
//If I can do it with relative ease, I should. But then I give myself way too much to do because I CAN do almost anything with relative ease  :-D. I'm glad I use "TODOreq" as much as I do actually. I should probably use it more! It is especially useful when building. The word itself is enough of a huge help as a pointer to empty curly brackets.
//Ok basically my rpc client interacting code (which i've named "rpcbankserverhelper") and my rpc server interacting code (which i've named "rpcbankserverclientshelper") need to both i forget
//fuck
//ahh yes. need to both be megaship/mothership compatible. they need to be able to operate on the use case where there is a long standing app that wants to completely destroy (in memory) the rpc service. it knows it can read the .dll again in order to get the rpc service back in memory. we use a LRU cache releaser of course, but under some cases it simply isn't used. or perhaps not and it's always used, idfk.
//i could code this example for the case where we're optimally coding in a typical/singular manner the two "initialize" methods together (as i've already done)... but it is definitely smarter when it's so easy to do to code for the "'client' and 'server' don't intantiate/start/stop at the same time (or "daisy chained to" (EXCEPT SPECIFICALLY IN THE USER CODE ONLY) to one another). i may have said what i'm trying to say completely wrong. lol gl;hf. oh and i forgot a close quote in there so: ". in my case my "test" class represents the user code so the user code needs to also handle the "initialize" (that has NOTHING TO DO WITH RPC (except incidentally also probably does!)).
//It just makes sense to code the bankServerHelper to always know that the bankServerClient is always "data ready". it will request that we finish ourselves off and report our result at attempting to do so before attempting to take itself off of being "data ready".
//except in some senses, or i guess in some use cases, being "data ready" means we must be ready for the rpc service itself! in those cases we have to do something differently
//but i'm referring to the fact that the rpcBankServerClientsHelper (which lives on the server btw) needs the rpcBankServer (business, aka "user" code) to be "data ready". It makes more sense in that instance.
//how it translates to the client is where i'm getting confused a bit. i guess a better word that fits both client and server is "react-ready". the rpcServerClient is react-ready to the rpcBankServerHelper (autogenerated chunk of code that lives on client and eases communication with server/peer-really). the  rpcServer is react-ready to the rpcBankServerClientsHelper (ditto but reversed where necessary). the react-ready object is also the "controller" object. the main guts of the application that the gui should communicate with! it may or may not be an overoptimization to split the controller up from the "business" that the autogenerated rpc network code is communicating with. test is effectively my "controller", and that is perfect "prototyping" now that i think of it.

//Server becomes react-ready by initializing a database etc
//Client becomes react-ready by getting the signals connected to the debug GUI (in this spec), or by doing some other utilization

//ReactAndActReady is more appropriate because broadcasts are Actions (Acts?). A reaction is more generally associated with a request... but on the client the reaction is actually to a broadcast!

//What the fuck am I on about?

class RpcBankServerClientTest : public QObject
{
    Q_OBJECT
public:
    RpcBankServerClientTest();
private:
    BankServerClientDebugWidget m_BankServerClientDebugWidget;
    ObjectOnThreadHelper<BankServerClient> m_RpcBankServerClientThreadHelper;
    ObjectOnThreadHelper<RpcBankServerHelper> m_RpcBankServerHelperThreadHelper; //TODOreq: or is it serverShelper? plural. idfk. i think it is singular here but at a different level it can be plural
    //BankServerClient *m_BankServerClient;
    //RpcBankServerHelper *m_RpcBankServerHelper;

    //Instantiate
    inline void initializeBusinessAndServerHelperIfReady() { if(checkBusinessAndServerHelperAreInstantiated()) initializeBankServerClientAndServerHelper(); }
    inline bool checkBusinessAndServerHelperAreInstantiated() { return (m_RpcBankServerClientInstantiated && m_RpcBankServerHelperInstantiated); }
    void initializeBankServerClientAndServerHelper();
    bool m_RpcBankServerClientInstantiated;
    bool m_RpcBankServerHelperInstantiated;

    //Initialize
    inline void emitInitializedIfBusinessAndServerHelperAreInitialized()
    {
        if(checkBusinessAndServerHelperAreInitialized())
        {
            emit initialized();
        }
    }
    inline bool checkBusinessAndServerHelperAreInitialized() { return (m_RpcBankServerClientDoneWithServerHelperDuringInitialize && m_RpcBankServerHelperInitialized); }
    bool m_RpcBankServerClientDoneWithServerHelperDuringInitialize;
    bool m_RpcBankServerHelperInitialized;

    //connections-only pointers
    BankServerClient *m_BankServerClient;
    RpcBankServerHelper *m_RpcBankServerHelper;

    void daisyChainConnections();
signals:
    void initialized();
    void d(const QString &);

    void rpcBankServerHelperInstantiated(RpcBankServerHelper*);
    void initializeRpcBankServerHelperRequested(MultiServerClientAbstractionArgs);

    void startRpcBankServerClientRequested();
public slots:
#if 0
    void init();
    void start();
    void stop();

    void simulateCreateBankAccountAction(QString username);
    void simulateGetAddFundsKeyAction(QString username);
#endif

private slots:
    void handleRpcBankServerClientInstantiated();
    void handleRpcBankServerHelperInstantiated();
    void handleRpcBankServerClientDoneWithServerHelperDuringInitialize();
    void handleRpcBankServerHelperInitialized();
};

#endif // RPCBANKSERVERCLIENTTEST_H
