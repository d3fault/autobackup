an overview of what I'm about to attempt, because I'll likely forget in the midst of it.

-messageIds, fuck I don't know what to do for these anymore :-/
-the message size pre-pending code needs to be inserted. nothing new here
-pending lists for each action on the rpc client, matching them up with results, also 1 timer per action type that times out using an averageLength*1.5 = 'time-to-re-ask' scheme. the time-to-re-ask message should be slightly different than the original request... so rpc server will be able to see it and easily know what the fuck's up. he'll have the answers. either the message never made it or our response didn't or the business never returned. is there another one? gotta handle the scenario where the rpc server is on it's second attempt at getting the business to behave when we receive the time-to-re-ask from the rpc client. this is actually a quite likely scenario because the rpc server's timeouts will be significantly lower than rpc client's. Maybe like 10 and 5 seconds is a better starting point btw? Idk it doesn't really matter that much since we use 'detected' values anyways after the first one comes back and we can measure it :)
-pending lists for each action on the rpc server, matching them up with results.
-ack the broadcasts. will have to create an ack type i bet... specifically for broadcasts.. since actions seem to be going the 'happens-before' route (with cool timeout functionality i invented (something like that makes me wonder if someone else came up with it also. wouldn't surprise me at all))
-make the whitelist programming in the slots in the business all good and whatnot. need to modify the dispenser/imessage logic too?
-the way our rpc server ack's his action response to the rpc client is by watching the message ID until it is re-used by a *new* action request (specifically, not the 'time-to-re-ask' message thingo, which will also have the same message Id)

3000ms 'starting point' for the time-to-re-ask timeout, until we get > 0 results with which we can perform averaging maths on. this is for both rpc clients pending list and rpc servers. actually rpc server's should probably be shorter, maybe 15000ms? that gives him 1.5 seconds to re-send the message into the business. but shit, if i am losing messages in the business then something's definitely fucked. idk i seem to have convinced myself to code it anyways :-/. It's not for me, it's for future users of Rpc Generator. I know how to code the business right, obviously. Then again, I can't stop/predict crashes in the business... so maybe it'll benefit me too. idfk. How would I even handle that case? Just after the second failed attempt at sending it into the business... return a generic error (or perhaps a specialized error? (TODOreq: or perhaps a specialized error for ME (private dev log) and a generic error message for Wt-USERS))

note: the rpc business --> business timeout thing MIGHT need to operate on microseconds instead. I mean the calls might repeatedly take 1ms or less (rounding up every time)... in which case even the tiniest hickup making it 2ms will trigger a time-to-re-ask thingo. wait no it won't, the averaging portion of it means we'd practically ignore the 2ms hickup :). wait no it doesn't, rofl. it's ignored in the averaging [assuming 99x 1ms messages already in the averaging list], but not by the timer checker slot thingo (connected to QTimer::timeout() [signal]). Oh wait wasn't I going to have a minimum-ms-wait thing? like 50ms or 100ms or something? It should override the timer.start(calculatedAverage) call. Not sure if we have to stop/start the timer or if just changing the interval while it's still running is ok. besides the point. won't stopping the timer in the timeout slot mean that there's already a timeout waiting/watching to be timed out (and he gets destroyed/disabled/stopped when we call timer.stop()?)? I don't know how QTimer works internally, this might not be the case. But if it is, it seems like it might be a costly overhead worth working around TODOoptimization

maybe to start with I can just record the timings between [rpc server <--> business] and then output them debug and see how many ms the business calls take on average (do release mode btw :-P TODOreq)... then from there determine if I want to use ms or microseconds.

I'm still slightly hesitant on whether or not I want the timing/re-ask'ing thingo to be used on the rpc server -> business... since it's such an insignificant amount of time, and the rpc client is already doing it for us!!!!!!!!!!! shit actually that's my best point ever. I don't _NEED_ to do it on the rpc server... because it is already being done on the rpc business. I should still keep a m_Pending list and even a m_ResponseIsPendingAck ('new' requests with a re-used message ID will ACK the pending response).... but I don't need to worry about all this timing stuff I don't think (at least not TWICE). Yea fuck it. Especially seeing I doubt the business will even fail that often... let's just let the rpc client's average/timing thingo be the one to eventually trigger my 'where the fuck' message.... and we can then easily determine if it got lost in business by seeing if it exists in the m_Pending list on the rpc server (or the m_ResponseIsPendingAck list... which simply means we just need to re-send the response because the response didn't make it back). FUCK YEA CLARITY HERE I AM.

--EVENTUALLY:
if the rpc server's time-to-re-ask thing fails once (so that means we actually failed twice total), we back out/up (in the design in mah brain it makes sense!) to the layer that selects servers.... and select a different one. oh and we'd also mark the one that just failed as offline or whatever (which'd start it's own periodic 'ping' thingy to detect when it comes back)



^^^^^^^^^there's no way in hell i'm going to code all of this before passing out