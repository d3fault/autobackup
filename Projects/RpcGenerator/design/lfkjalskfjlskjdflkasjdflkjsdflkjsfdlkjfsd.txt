I keep staring at the code like it (the solution) is going to jump out at me. I know what the problem is, I just haven't managed to squeeze out an answer. I know that typing about it in this notepad instance will bring about the answer with relatively minimum effort. All I really have to do is keep typing. Who cares if there are bouts of stupid, they can be ignored. Remember that your program must compile and function and pass tests, so stupid is filtered out.

The problem is retryBit, retryBecauseConnectionLostBit, responseRetryBit, and toggleBit are confusing and I know I've said in more than one case that I could use toggleBit as a retryBit or something or other. The problem is that right now I need to make slow as fuck messages that are in business pending during an entire fucking merge to not go on and be sent to the client, because in this case it is a stale request and the stale request belongs to the old connection, the merged/new connection has to re-request it (just like all of the pending ack ack ones [should he need them (they might have made it, we have no idea (but toggleBit will tell us (TODOreq: toggleBit has to be coded carefully to survive merges. this might be easy and/or already done incidentally)))]). But then eventually we want responses received from business pending to actually go to the client! Those are the ones that have requests from the new client.

Ok solved, easy as fuck just like I knew it would be:
We set a bool on each of the messages (the bool does not go on the network, it is only in memory) for all requests that we have received (so iterate business pending and ack ack list and you're golden methinks) to indicate that they are stale. We check when receiving one from business pending just if it's stale, we don't need to "look it up in a list" or anything. If it is stale, it sits in pending ack ack.

All new messages won't have stale set (TODOreq: set stale back to false during the message 'recycle') so they go through to the client like they should.

A client knows both the list of messages he thinks he sent, and the new list for the new messages post-merge. The point is he can differentiate between the two. He leaves the toggleBit untoggled for the ones he think he sent, and toggles it for the new ones (using the same recycled message id batch from pre-merge). When the server receives a message for a toggle bit that's in pending ack, he sends it like usual. It doesn't matter if it's stale at that point, it only matters if the item is stale when it's received from business pending. So as a TODOoptimization we could only iterate the business pending list and set their stale flags.
There is also what to do with the ones STILL in business, but those can be marked unstale safely by appending their message id to a list that is ONLY checked when stale is true. It's like a "last chance to be proven non-stale" (it is now non-stale since we are re-requesting it!). We can't simply flip the stale flag (wait a minute, we couldn't flip it anyways for setting! the clientshelper needs to own the hash relationship between messages and their stale status, and we could optimize over it by seeing if it's empty before doing any lookups) because the ones in PB are most likely on another thread! I guess as long as the business itself doesn't set it to stale, that it's SORT OF ok to do it... but it's still bad practice in general for two threads to modify the same object at the same time. I don't know if this is as bad of an idea as I'm making it out to be. Since they are different members on the same object that are being accessed, maybe it is ok? Still the problem is also solved using a hash that lives on the server thread. So I guess instead of setting a flag that says it's un-stale, I could just remove it from the hash (if I go with the hash method) lmfao. I think doing the "stale hash" method is ok and won't be too much of a slow down because most of the calls it hits in hot spots are calls to .isEmpty() before proceeding, which I think is optimized to be fast? It will also almost always resolve to true too, unless a merge is in progress or has completed. Since we are later removing messageId from the stale QList when we finally send it, it is easy for us to just remove it from stale when we detect that the toggle bit hasn't been flipped. If it isn't in stale list, that means we are doing a normal retry so it's either in business pending or pending ack list. TODOreq: Whether or not the retry was stale to begin with is what tells us if we give the business pending's a time extension, since requests are retried immediately after a merge and so we might not have let enough time for a normal timeout (for that specific message) to occur. Does this mean sending works but receiving doesn't? WTF psbly nvm.

TODOreq: I definitely need 2 "status?" signals. The first one detects/corrects requests/responses getting lost, the second is the timeout for business pending. If we get a response to our second "status?" and it's still unanswered, then this is where the system-wide shutdown procedure is initiated. The first status is sent at maybe averageMsResponseTimeForThatMessageTypeToThatServer*2 and the second one is sent at like averageMsResponseTimeForThatMessageTypeToThatServer*3or4or5 -- not sure tbh.

status2 needs to be at least (status1.length*2)
^^^^err forget what formula is was making, but the general idea is that status2 needs SUFFICIENT (calculated using averageMsResponseTimeForThatMessageTypeToThatServer) time to wait for status 1 first. I guess if status1 times out (which might need to take as long as status 2 would have taken), that server is assumed down [and additionally we might need to bring the entire system down like before if in-case there are messages stuck in business pending. man i need byzantine!]. But if by some weird luck we know none are in business pending, we don't have to shutdown entire system.

Status 1 can be responded to with "still in business", which triggers the eventual sending of status2... which we hope doesn't return empty handed! If status 1 responds, status 2 will very likely respond... but that is definitely not always true. If status2 returns empty handed or not at all, we initiate system shutdown because we aren't byzantine fault tolerant fml. The timeout for status2 also needs careful consideration, but probably not as long as status1's timeout (since we've already waited more biatch)???? I mean the timeout that we wait for status1 to return, not the timeout before we dispatch status1! Fuck, confusing.

Status1 delay = average*2
Status1 timeout = diff-to-Status-2-delay (Status1 delay exactly if forumla directly below doesn't change)
Status2 delay = 2*Status1
Status2 timeout = average*2