For RpcGenerator, I could do something along the lines of putting the ActionRequest in a QScopedPointer (though not, but something SIMILAR -- or at least overriding the destructor method) so that when destruct is called it calls message->doneWithMessage. I could give them a QScopedPointer inheritted class instead of the message if they want to do just that, which would mean they don't have to call doneWithMessage on it, it just sends when there is no longer scope (which is good for dealing with exceptions etc). It has to always be valid and has to be in an Error state by default. Whitelist programming woot). I would need some way for me to still be able to pass the message around to different objects/threads using QMetaObject::invokeMethod, but some hacky helper method could be put on the QScopedPointer deriv in order to indicate that we're going to "Continue" in another object/thread and with that one we should use the same scoped-auto-doneWithMessage unless they again call the hacky "delayScopedAutoDoneWithMessage". Would the picker-upper object/thread have to somehow re-initiate the scoped-ness of it? I think yes.

QScopedAutoSendingOnDestructMessage theCustomQScopedPointerWithItSetUpToDoneWithMessageOnDestruct<CreateBankAccountMessage*>(message);

//had: = /* pretty sure it comes as an arg */messageFromTypicalRpcActionRequest->enableScopedSend(true);
, but it is easier than I thought





THE MESSAGE IS NOT IN "ACCEPTED" STATE if the user's rpc business code does not call the wrapIntoScopedPointerDeriv code. If the message is not [at least] in accepted state when a "requestRetry2Status2" is received, we can safely disregard that business impl (for that specific message) and if we can do that with all pending businesses (what if some are successful still? they would need to have been attempted before ours because we don't allow ourselves to schedule any more once requestRetry2Status2 is received (and until it is dealt with (sometimes we get lucky?)). If we can guarantee using the above method that no messages in an [at least] Accepted state (other states are, for example to reference above: BeingPassedToNextObject), then we don't have to shut down the WHOLE system (all businesses on all servers)... we only have to mark that business as disabled and notify others to ignore it. Since each business has a full copy of the db via a dht client, that one business being down is not detrimental to the entire state of the db (unless we have Accepted... then we're fucked because we don't know the state of the request, it might be partially complete). I think I should do that byzantine shit but eh it's just more fucking work god damnit.