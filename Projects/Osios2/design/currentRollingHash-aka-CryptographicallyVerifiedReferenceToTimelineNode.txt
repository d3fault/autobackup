Revision, Edition, Hash, CommitId, TimelineNodeId, TimelineNodeId_aka_HashOfContentsToBeCryptographicallyVerified (except then we give them the answer to the question we want solved to prove their saving of the timeline node). The hash of the timeline node must not be sent in plaintext over the wire at any point. The reason is that programmer error could make you access the received-via-network hash as your response (ON ACCIDENT) to the mirror-and-respond-with-cryptographic-hash-plx dht message (a request, incidentally), the base (only? (excluding bootstrap/dc/etc)) message of the dht and the primary justification of (primary reason for (had: core reason of)) the application's existence.

But back to the point, what do I want to refer to nodes by something. The rolling hash sounds good. Except for the very first timeline node, the rolling hash for a given profile (a point in time that is recorded and referred to by something (the rolling hash)) is hash(rollingHashForTimelineNode(currentTimelineNodeIndex-1) appended to, catted with (order doesn't matter) hash(currentTimelineNodeContents)). Very simple really to put into words: the previous rolling hash is hashed with the contents buffer of the new content itself as a whole to become the current (the way you refer to that timeline node that was hashed as well) rolling hash.


failed attempt after 'is'
timelineNodeAt(theRollingHash



It is also effectively the dht state for a particular timeline node (and all it's previous history (assuming proper periodic hdd testing procedures are introduced and followed)).


QByteArray currentRollingHash /* or, rolling hash for a given timeline node */ = hash(rollingHashForTimelineNode(currentTimelineNodeIndex-1) appended to, catted with (order doesn't matter) hash(currentTimelineNodeContents));


Again, tempted to combine profile rolling hashes into one, but WON'T FOR NOW to KISS.



The DHT hello should not include merely the number of timeline nodes you've produced (although that too may be sufficient actually fml idk), but should announce it's most recent cryptographic hash generated/placed on it's timeline node. The issue/matter/problem/question/decision of synchronization appears. Do I want to trust myself or the network. Obviously TODOreq the network cannot delete any of my timeline nodes. Only local user requests can MARK THEM AS DELETED (but never delete (tempted to put "unless compressing losslessly, but that has risks too" (small ones become larger over a big (swapped larger and big) period of time))).


The thing is, you can "refer to them" (trust their contents), or you can "refer to their cryptographically verified rolling hash" (not trust their contents). Since the system is based around "proof you have it by sending me the content that matches <current-rolling-hash-for-that-timeline-node> (the less frequent (had:infrequent) but mandatory hdd testing procedures!)", it somehow makes logical sense to also refer to the node by exactly that.

Do I want sync. Do I want pull-down if logging into the dht from another terminal? Of fucking course. Why the shit would I ever want to display stale content. So if this is ever released publically it needs PKI, but for now I cant do sha1 proving.


//the mirror one another:

onInsert(timelineNode)
{
	proveYouGotItByVerifyingItsSha1Bitch(timelineNode);
}
onPeriodicHddCheck(timelineNodeId)
{
	proveYouGotItBySendingMeTheEntireFuckingThingAndIwillSha1ThatBitchMyselfBecauseIdontTrustYouMotherfucker(timelineNodeId); //and this is why I love coding
}


Also I don't think PKI solves crypto hash verification on insertion. It would verify it on periodic hdd checks though, since the thing being gamed is the bandwidth itself (say you received it but really you only received a hash from a co-conspiring neighbor). Fuck public anyways, backup is my goal. Not efficiency. I am prioritizing this above all recently because it is a matter of sanity.