To have computer security, you must never let the computer out of your sight. This also goes for the keyboard, mouse, and monitor (and even a USB hub). Any of these mentioned devices could be logging your passwords. Up until a few seconds ago, I didn't know a way to get around the necessity to never let a keyboard/mouse[/usb-hub] out of your sight. Now the only things you must never let out of your sight are a monitor and the computer.

GUI: using a secure rng, scramble the alphabet/numbers/symbols and display them in a window. the user can then alt as many times as needed until key is selected, or click on it with a mouse. since the keys were scrambled, a key logger only gets a bunch of tabs that correlate with an in-memory-only (disable your swap ofc!!!) selection of keys. Once you shutdown and that memory is wiped (assuming the computer itself isn't logging you hue huehuehuehue), those tabs won't make any sense. Mouse logging is similar, but logging x/y coords with every click, that now are useless once that rng seed is lost at shutdown. Subsequent runs/logs also don't help them deduce your pw. So yea the pw goes into a lineedit and you copy/paste it whatever... it could even be a virtual keyboard type app and be typing into some other app (but idk how to do a PORTABLE virtual keyboard :/)

CLI: same idea (you type in keys that are mapped to different/shuffled keys. the map is displayed right above where you type), but I guess instead of a line edit you copy out of, it writes the end result pw to /run/shm/ (so apps could read the pw via: `app --pw=$(cat /run/shm/pwtempfile)`) or something. or we could make the assumption that tmux/etc is running and copy/paste is possible

Optimization: if using a series of dictionary words for your password (like you should be), the word could be guessed/auto-completed/thing, saving you some time and not decreasing security. It would decrease security if you didn't also do the following: a "use suggested completion" button/entry should ALSO be shuffled in there with the regular keys. If it was in a fixed location (or triggered from a fixed key), mouse/key loggers could determine the lengths of your words, or at least get closer to deducing the lengths of your words...

^^^^^ON SECOND THOUGHT, this optimization can't be used since a monitor logger would pick it up xD


re: monitor: (well nvm if you never let the pw be shown to screen, which is doable ez)... is the computer itself. Wait no after thinking about it more the monitor does need to be with you for this about-to-be-described technique. Ok in order for the monitor to not need to be with you, there needs to be no visual indication of which keys were selected. So usually when you 'tab' around on GUI buttons they get highlighted and depressed when clicked etc. A GraphicsScene would solve that (just don't allow the tabbing technique I guess: regular typing is fine, so is clicking). And with CLI you need to eat the readch before it ever gets shown to screen. I think that's possible, but I'm unsure. In both cases, you have to be clever/careful about the pw never being shown to screen. running `ps aux` might compromise your security etc, as might an accidental ctrl+v -- TODOreq clearing the clipboard after X seconds like KeyPass does would be a good feature. Hell, in all honesty, this idea makes a good password entry form FOR keypass (but seeing as it'll work with any app, it doesn't need such specific integration (that and I think KeePass is GPL :-/))



Note: those keyboard and mouse entropy techniques are NOT usable in this app. I'm just gonna rely on boost::random for now but gathering entropy might need a lot of consideration because I think /dev/random on linux uses keyboard/mouse activity for entropy (but also fs/network/etc)


TODOreq: also worth noting that you can't require them to press shift when entering keys (mapped to other keys), otherwise that keyboard logger in combination with a monitor logger could greatly deduce/determine your pw. So perhaps this app works best (or at all xD) with passwords that contain ONLY a-z 0-9 ... or other symbols that don't require the shift key (not very many). FML: my ultra long pw requires the shift key xD xD xD xD ffffffff WHAT WAS I THINKING ;op




Fuck wait no there's no way in hell to thwart the need to carry a monitor xD, I am dumb (I keep going back and forth on this): screen caps (monitor logging) + key logging = pw retrieved. So yea I'm back t "need monitor at all times". Good thing I have a 1.8" monitor :-D

so the need to carry a monitor means the optimization is back in. it's worth noting that you SHOULD use the same dictionary every time. changing it would give your attackers hints. you should also press the "use suggested word" action (itself bound to a shuffled key) at the same point each time. so completing "fucknugget", say it guesses it at "fuckn", you should press [use completion] after the same amount of characters EVERY time. just tiny things here and there can make you lose entryopy.

I also thought up a way to do shift/specials/more-keys-in-general. one of the shuffled keys could change the keymap mode, to.. say... uppercase... or pretty much just any key requiring shift. to get back to regular non-shift mode, you again press a shuffled key. I think it's a good idea, and I think it might even be necessary to protect entropy (unsure), for the key map PAGES (non-shift vs shift) to get reshuffled on every re-entry. again, just protecting against tiny entropy leaks.


I realized there's a huge problem with this app/design/security-solution and it depends on a properly implemented computer. It made me remember an Arduino Micro/Leonardo (any ard with "usb keyboard/mouse" abilities really) vuln: you connect the 'keyboard' to an online (implies infected) box, it uploads new firmware to your 'keyboard', you take the keyboard to your secure offline password box (that this app is trying to protect), the now-infected KEYBOARD types something allong the lines of `cat password > /dev/keyboardEeeproom`. I thought to myself, ok so just don't install the Arduino IDE/drivers on the box you're trying to secure.... BUT the arduino IDE/drivers SOURCE CODE could be embedded into the keyboard firmware and the keyboard could "type" it into the offline box and compile+install it (maybe not without root?)!!! This example uses arduino for simplicity's sake, but a custom/minimal keyboard/firmware could be used in case the arduino stuff is too big (but meh, just get a bigger flash on the ard/kb and yea). So the ONLY counter to that I could think of is: the secure offline computer's OS needs to be configured such that each enumerated USB device (might be using the wrong terminology here: what I mean is ONE FUCKING USB CABLE) must only be able to operate as ONE kind of usb 'device'. So it can be a usb keyboard or a flash (eeprom) drive, but not both. I think this rules out al USB hubs because the 'keyboard' could act as a 'hub' (which hides innocently) and then presents a 'keyboard' and a 'flash (eeprom) drive' as two separate devices even though they're only one. So yea, remove USB Hubs/splitters from acceptable types, then only allow each USB device to be 'one' kind. Aww fuck I just realized it could do: `sleep 20; cat passwords >> /dev/keyboardEeprom; [internally-unplug-itself-as-keyboard -> plug itself back in as flash/eeprom drive]`..... Fuck fuck fuck fuck this app/design sucks.... but it still does protect against vanilla hardware keyloggers (and mouse loggers, which i've never even seen but could surely exist). HOWEVER, if you do never leave your computer unattended with a keyboard/mouse plugged in, you really shouldn't have that problem anyways because you'd SEE it typing `cat` etc. but it could follow up with a `clear` xD. You gotta fucking stare at the command prompt, and shit maybe uninstall the `clear` built-in xD. So many gotchas, fuck computer security sucks.

OK HERE WE GO: the computer's OS should use a small as fuck whitelist of accepted USB types: keyboard and mouse. that is ALL. This does fuck with it's overall utility quite a bit though: passwords could still be generated, files could still be signed, but in both of those cases they'd need to be done manually/typing-each-character-out!!! with binaries this could be a huge problem, but however signing a commit is only a few hundred/thousand characters and then accounts for the entire repo (what I mean to say is: don't sign the files, sign the hashes of the files ;oP). It's _DOABLE_ I suppose, but idfk how to whitelist USB types. If I asked for help in the linux world they'd probably laugh at me since they don't take security seriously (or, they suck at security). But perhaps the OpenBSD d00dz would be able to halp.
Bleh typing in/out so much shit manually would be a bitch, but then again security is a bitch. I think this would actually be somewhat secure,  wow! At this moment there's a $5 computer and a $13 1.8" monitor available that would suffice (as long as linux itself suffices, which I don't know at this point. afaik OpenBSD doesn't install on that $5 computer, need one at like $30-$50 but blah I digress (not even sure OpenBSD could (read:WOULD(since I can't)) do it))


back to the GUI app: I think maybe I should disable mouse pressing if the width of ANY of the shuffled "buttons" (keys) is abnormal. For example the "SHIFT" button would be wider than the other buttons, since the word 'shift' is 5 characters instead of 1. a mouse logger could detect presses that are not in line with others and could, over time, reduce your entropy. I could also solve this by having shift be a special symbol, maybe that sexy S that's two S's on top of each other... but really any key that's not accessable via SHIFT (unicode is huge so my options are too) -- TODOreq: use a symbol 'SHIFT' _character_
^OH RIGHT the same applies for the 'use completion' button/character. I guess at the top of the app I should have a legend for those two (and any others I come up with along the way)


TO DOnereq: actually you know what, I think after EVERY key press the keymap needs to be reshuffled. to protect against "ee" and "oo" etc analysis. I might be wrong, but I'm damn sure it's not going to HURT the entropy.

TODOreq: if a keymap "page" is uneven, ie there are 'empty' 'buttons' on that page due to it being the last page and there not being enough keys on that page to fill all the 'buttons'... then we should shuffle the 'blank'/empty/disabled/non-mapped buttons into the gridlayout. I think this protects against a tiny as fuck entropy leak that might be substantial after a long period of time, but maybe it doesn't do anything at all xD. Again, at the very least, it wouldn't HURT the entropy.


So hmm I'm wondering how this 'keymap page' thing is going to work seeing as I reshuffle on every key. When there's only two pages it is fine to have the 'next page' button simply be a 'NOOP -> reshuffle' key. You might have to press it a few times for the key you're looking for to show up, but it wouldn't be a big deal as long as there aren't very many keymap pages. To support assloads of characters, however, we'd need the "reshuffle" to generate every page, and then the 'next page' button doesn't trigger a reshuffle (and there's a 'next page' button on each page ofc). Only whe you select an ACTUAL key does it reshuffle. "use suggested completion" is considered an actual key ofc, so it triggers a reshuffle. The only one that doesn't is 'next page'.


It's cool that a person can watch your keyboard as you type in your password and you're still safe. As long as they can't see your monitor ofc :-P. I envision myself making a tiny ~1ft cube out of foil around my head and the only thing in there with me is the monitor (the comp doesn't need to be in there I don't think, but that will change in the future when x-ray/etc scanners are so precise that they can look at the electricity flowing through a computer and see what it's doing (this also applies to a human brain, fml.jpg)).


Blah, disabling usb TYPES would be pointless if they could then be reactivated again [using the keyboard or mouse]. And permanently disabling usb TYPES for a given OS installation would be pointless if they could type out the source code to + boot a whole new freaking operating system (and from that new os, they simply mount the old OS and read the pw file or inject a sw keylogger etc). So what is needed is a locked down as fuck OS, kind of like what video game consoles use. No compiler access, no system access, just "KEYBOARD + MOUSE + SIGN TEXT + GENERATE PASSWORDS" only OS. Yea err ehh uhmm backing up the generated passwords or signing keys would then be impossible rofl, fuck my life.
