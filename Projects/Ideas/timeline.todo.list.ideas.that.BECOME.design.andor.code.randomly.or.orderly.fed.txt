i should have a set of modules which are not dependent on each other and it is more like a tag for ideas that i've yet to come up with (i can throw ideas i've already had into the system about to be described) and then that particular set of modules (in "idea" state (others:design,code(although perhaps eventually the two may merge(but right now i use the "design" folder in my project folders (on per-project basis) to hold like notes and shit. so perhaps notes is one of the states as well? like i mean especially if the two merge together, that seems to be the case. or perhaps i am using the word design erroneously? i mean i do put my software designs in there as well but i never really thought about using a notes folder)))) is fed to me "randomly" as in mathematically randomly. i can of course prioritize a queue which is processed "before" going into random processing mode (or perhaps both "queue mode processing" and "random mode processing" are indefinite-until-user-ends-it) and basically random processing mode (i can even eventually have it feed me coding tasks themselves, but lets not get ahead of ourselves (TODOreq)) is my way of chaotically influencing my environment. i have no idea what releasing (AS IN CODING) that particular set of ideas in that order will have on the universe, but i imagine "the people" will devour and refine (or perhaps destroy/illegalize/etc) all softwares released and eventually it will pay off in that some one of "the people" will use them all together (or just subsets) in a "way i never would have predicted or thought up myself".

care should be taken and thought should be dedicated towards making sure no harm is done to anyone, but our aim is to hit random ass spots in the "freedom to *" domain.

it is still my will because they will be all (at least initially (or even if i do eventually allow others, i can still filter out my own!)) my own ideas.

the queue processing mode feeds me my "coding todo list", which is dynamic as fuck and the building of that list is replay-able! i can add to a "coding todo list" by making an item my "next thing to do". so maybe this has a shit ton of overlap with how "music timeline" works implicitly. using git commits is probably good enough for now, but the fact that multiple items will be added at once "kind of" fucks us up. i think later it will be recorded/replayable on a single-item level, but eh hacks are hacks these days...


so like queue processing mode (all of these are "timeline nodes" so to speak, referring to that old design with "timeline action nodes" (which would be the individual tasks processed in each corresponding mode, whether it's queue or random)), random processing mode [err i forgot what i was going to say after that comma and then guessed it'd been that, but can't go any further]

queue processing mode is how i get shit done on the short term (typos: down, shurt). i have a specific application i want to make NOW and it is my computer-assisted (task fed) way of not having to think too hard about how to design it. since i'm doing the rapid prototyping design, you never have to design the idea until you actually make it (it's prototype). this gives you like a zooming functionality mentally and when you enter those zooms then you forget what the "next task" is (unless you have good memory, or you have a manual todo list somewhere). this will allow you to zoom in and out at will without ever losing your exact spot in the "project". It would seem plausible that when in queue processing mode, you must first select a project. or you can have a default project (mine will be d3fault ofc). you could even have "one task from each project" fed to you so that you are constantly improving the group of projects you care about incrementally... should you love them all equally and be unable to decide! of course you could use random project selection but then you are becoming ambiguous (but not impossible though) with the random processing mode! i personally like the "one task from each project" mode (where the algorithm makes sure each project has one task processed before doing them all over again (like my round robin algorithm recently written (easy)))... and actually it seems irrelevant if i do random or 'ordered' if i'm using that round robin technique for both~