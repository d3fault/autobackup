d3fault filesystem interface. think about the .rar/.7z interface for AES type but create interface for RSA type

see, we want to be able to log in without a password and be in submit-only mode. thumb-drive/raspi is account comrpomised on item compromised
wait don't i want it to be submit-only-write-only mode 24/7? when would it ever be INSECURE, then? if i could 'get new identity' (equivalent to changing password).
what is the password even used for? to look at old/private submissions?
yes.
YES
that's exactly it
that's all
in that case, you'd want to let the verification finish. if it's even plausible. it might suffer large security holes such as always being able to be faked. couldn't the filesystem itself lie? yes.

class INoDeleteFileSystem
{
  slots:
    TimeLineNodeReference WriteForever(SinglePieceOfData); //what the fuck do i do with a timeline reference? do i become the owner of it?
    //you know, i think i've written this interface before a long time ago. and i wrote the same thing and that's all i ever wrote. i mean seriously, what signals are there? you want to get notified on every write? well, yes. kinda. i mean tell me about shit in bulk. but writing async/efficient and NOT one-at-a-time is difficult. difficult but doable. so how long should each server hold onto a message and compile on all following messages for? and couldn't i make it flush after a certain amount too? one or the other. couldn't i also control the 'average' speed at which the message queue is flushed by means of autoscaling the number of messages (assuming a relatively constant [for the short term we're measuring] rate of messages. i mean it will increase as usage goes up but that's not going to hurt)

  signals:
    void ThisWasWritten(TimeLineNodeReference, Title /*title might be _IN_ timelinenodereference idk*/); //maybe title is inside the timelinenodereference? hmm i can't remember how i want to deal with titles anyways. i shouldn't. titles would need a maxlen and then that maxlen becomes the max message len because you don't have to click it to see it. this makes no sense. how could you have a filesystem without file names? gah i just don't want to write them a lot of the times. i should just identify them by the date and time (epoch). the timelineNodeReference too is identified by the date and time, but it CONTAINS metadata, whereas the object it refers to contains the data. so like we write the timeline node reference on the timeline (also). whether or not it says the title is depending on whether or not it's public or the key was previously/later-on published. the system just 'knows'.... but ALSO send the user that wrote it, as well as every user connected, teh timeline node reference. the reference contains, optionally depending on anonymity/publish/private/etc settings, it's public/private encryption/decryption keys. the timeline node reference also has a field for 'node-referring-to', which is just an exact/singular (precision is added as needed) time. at least, teh beginning of the incident. but some incidents are just 1 moment. ie pictures. if it's a video, it plays regular speed. each moment of the video is NOT referable into the dht like that. you must refer to the starting point and can then specify an [exact] offset. the reason for this is because moments will exist overlapping each other all the time. but it is impossible for 2 moments to happen at exactly the same time. and if they do, a 'thread' just does it on a first come, first serve basis. it is IMPOSSIBLE for 2 messages to be processed by that thread at the same time. text is displayed with accurate beginnings, endings, and backspace positionings... with the average-cpm used/stored-in-the-meta the rate at which the cursor progresses. pauses of any length over [x-dynamic] ~3 seconds set an 'end point' (or perhaps just 'break point'?) and keep track of how long you sat there for. it is user configurable whether or not you wait the entire duration of their break. we accept any kind of data but really text/picture/video is all there really is. it's just that text has multiple sub-categories: writings/documents (which i intend on using an efficient*** tangentify to represent), emails, code. probably others. i mean we could handle any kind of file tbh. rar/zip/anything. this gets me to another subject. i want anybody to be able to contribute. this is a hugely different goal/objective/PROBLEM (though they definitely still can be implemented together). i want them to be able to create a new text category interface/handler from within the app. or anything they fucking want. idk this goal sounds weird and hard to maintain? or like, how do i accept patches? i'd be overloaded. isn't that a good thing? no. it isn't. i think i should set a beast loose. the default category. there is the d3fault category, mine... and the default category... everyone's. i ask them at startup/first-launch: which do you want to follow? d3fault vs. default. i can explain the differences: 'default is an attempt at a collective average voting of software configurations' and 'd3fault is my personal flavor of it. i trust it a hell of a lot more than i would the default implementation. but it also might be updated far less frequently'. so default is vote-based inline-editable gui configuration (they both have write-only-access to the same file store. maybe the file store itself should NOT be inline-editable, for obvious reasons --- BUT IF IT'S A NETWORK OF TRUSTED _USERS_, it should be. oh my god i've gone through so many tangents on this line no wonder i'm so fucking lost. on one hand i'm lost, on the other... this design actually sounds doable. difficult and long, but doable.
}


how does this factor in the predictable seed chaining? don't i need to predictably encrypt? or something?