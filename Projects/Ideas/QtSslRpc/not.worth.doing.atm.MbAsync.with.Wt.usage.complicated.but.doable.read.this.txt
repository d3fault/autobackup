the rpc server interface is generated by a specification
the business layer implements the generated interface and performs operations on said object

additionally, pre-decision to send a bank rpc, we need to do tests with the bank object
see if they have enough funds, for starters. if they don't, there is no need to do an rpc call to the bank

so the bank object is accessed by the rpc client business code, the rpc client auto-generated code, the rpc server auto-generated code, and the sever business layer implementing the interface

what is a race detection on one (the appdb, checking to see if a bank account has been created yet in appdb bank-cache), is the functional code in the server (would be stupid to NOT check that the user is already created before creating it)
race detection #2 does not apply to the server rpc's cache (master) of that object

who owns that master cache?
the auto-generated rpc server code?
the server business logic?
or does it own itself?



so a 'race detection #1 _AND_ functional sanity check' combined into 1 pure virtual function
whereas race detection #2 is virtual with a default return of doing nothing
the rpc client generated code implements and creates race detection #2 and supporting code

for an rpc generator, it definitely would make a lot of sense to use a generic "request" / "response" message that any user-defined message latches onto/uses





i think technically if i achieved all of this, the only code to write would be the wt front-end (and it would call simple functions to do rpc/auto-post NOTE write more about this lower), the app logic for appdb, and the server business layer (just once :P)

Re: WServer->post
the ASyncMb object shouldn't be used by listening to an event
even though it should for the appdb <--> bank server, for the rpc client interfacing handwritten logic code. app logic
with Wt front-end, we can't just listen to a qt signal for a slot

ASyncMb needs to have two usages, one of which is passing a WServer->post callback (and sessionId)
this WServer->post callback is also used to inform the wt front-end of updates (pushes them to them)
remember that since it's ASyncMb, it may already have data right when it returns and should be checked
if not, "Loading..." and wait

//for "app logic" usage of AppDb <--> Bank Server RPC Connection
ASyncMb *bankResponse = IAbcAppDbBankServer::createBankAccount("username");
if(!bankResponse->responded())
{
  connect(bankResponse, SIGNAL(responseReceived()), this, SLOT(handleBankResponseReceived());
}
else
{
  //cache hit (already created in this use case)
  processBankServerResponse(bankResponse); //app logic takes variables out of bankResponse, probably for using in appDbResponse. this too is probably pure virtual app logic, idfk
}

//for "wt front-end" usage of WtFrontEnd <--> AppDb RPC Connection
ASyncMb *appDbResponse = IAbcWtFrontEndAppDb::createBankAccount("username", WtPostCallbackDetails);
if(!appDbResponse->responded())
{
    //do nothing. we are already 'connected' because we used the WtPostCallback operator overload
}
else
{
  //the cache still might have been a hit
  processAppDbResponse(appDbResponse); //pulls gui elements out. probably per-view pure virtual type shit
}



we also need to remember that the WtPostCallbackDetails will probably NOT be used for pushing updates
there is a "view changed/contents-requested" MbAsync call... THAT'S the one that says "give us all updates related to page x"
and there is also a "perform this action, let me know the results" MbAsync call. I guess it's obvious that the results may be updated in the future. TODOreq: should the updated/new/requested (and now responded) values be appended to the list of objects being watched for updates this referenced during the "view change/gimmeh-values-plox"? it becomes a value of the page... shouldn't that mean it gets updated? do we even need to? couldn't we just leave the updated values ASyncMb alive on the heap and it will continue to receive wt post's through it's callback? i am unsure and this needs further thinking


i think i can reasonably conclude that this 'qt auto-caching object + rpc generator' is out of the scope of my 'make > $0 asap so you can move out' retirement plans

still, it will probably definitely be worth it to:
a) invest seriously in this later
b) outline how it may be done (auto-generated code modifying the user supplied object seems complicated. maybe an iobject with it's own definitions in the interface?) while coding ABC