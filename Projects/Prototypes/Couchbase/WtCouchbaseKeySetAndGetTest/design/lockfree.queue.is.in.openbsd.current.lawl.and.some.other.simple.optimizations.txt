mfw OpenBSD has boost 1.53, which has LockFree::Queue. BUT then I realized using a single lockfree::queue isn't horizontally scalable anyways so my new variable amount of message queues (protected by mutexes) is actually a pretty cool guy eh. i can easily swap out the mutex+message_queue for lockfree::queue. I just won't be using "try try try lock" anymore: we'd use the "random()" we got first. A change in design which applies to both methinks. Only generate random number on WApplication instantiation, then increment it (looping around to zero) on each use instead of getting a new one. Would be sufficiently random. We only want to randomize between WApplication instances, and yea it'd save time I guess, instead of generating a random number for every get/store. Another (lol OT now) optimization is probably to have way more than necessary queues (both kinds as per above (applies to both designs)), so they never compete with one another. 10 Wt threads, 100 "queues" = low chance of competition... and meh 100 queues costs very little. If I have queueCount == wt pool threads, then ALMOST ALWAYS will the try_locks fail and it use the very last blocking lock.

And now it's a matter of whether or not "event_active" is thread safe. Sure it's thread safe in that the thread that calls it is/can-be on a different thread than the event callback, BUT is it thread safe in that multiple threads can simultaneously call event_active passing in the EXACT SAME "event object" (which is registered to a callback)?? If it isn't thread safe like that, then I do still need mutexes protecting the event_active calls like I have now, and lockfree::queue would probably not gain me very much (still some i'd imagine...). In the current impl, I put the event_active in the mutex lock just because I was erring on the side of caution and because it didn't seem like it would make much of a difference either way, but now that I'm thinking about replacing mutexes with lockfree::queue altogether, it's a question I need answered.
^^Right so dove right into libevent's source and determined that the first thing event_active does is aquire a lock! Woot that means I don't need to (it also means libevent sucks :-P). Had to figure out what __buildin_expect was doing since it does that shit before the lock, but eh seems thread-safe (*crosses fingers*)... is just checking that the event isn't null afaict (why do they presume that it isn't!?!? would the optimized path be the opposite (FUCK IT NOT MY LIBRARY))