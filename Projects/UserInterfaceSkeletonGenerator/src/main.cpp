#include <QCoreApplication>

#include "userinterfaceskeletongenerator.h"

//god mode
//TODOreq: when I "parse the class decl [string]" and populate UserInterfaceSkeletonGeneratorData, I should present a modal dialog to the user that has a list of the signals/slots that class has. maybe even public methods, since those are usable as slots in Qt5 connect syntax. anyways they are all checked by default and there are corresponding "uncheck all/check all" buttons. because we don't want to obligate the gui to using EVERY signal/slot/public-method a BusinessClass exports!! as a simple example of a BusinessClass slot that I don't want to have a corresponding "Requested" signal in the frontend for, I can look at this very app! generateUserInterfaceSkeletonFromData() is a slot in my business class that I DON'T want to comm with from the front-end. that was made a slot because it would be useful to other coders who want to #include this app's business class and would populate 'data' using whatever method, psbly via a gui like d=i. hell I might even do just that if/when I decide to put this project into d=i (but I still want it standalone [first]). -- anyways getting back on topic: I think that the "list of 'checked'/selected signals/slots/mb-public-methods-too that that modal dialog returns.... should be used for BOTH the cli and gui. I think that is the case, yes, but I might be wrong. So it matters not which ui impl type I choose to generate first, the "selecting" stage only needs to be done once. So I either need to persist those "selections" somewhere so the 2nd+ ui impl type(s) don't have to re-ask for them in order to generate, OR I have to _parse_ the [first generated] ui stub impl and match it's "Requested" signals to slots on the BusinessLogic. both are doable, the 2nd one sounds harder and also more error prone (false positives). the 2nd one does have the advantage of not having to keep track of some fucking file... but eh using a filename pattern like [businesslogicclassheaderfilepath.h].uisgd (or even trimming off the .h suffix if I want) to automagically keep track of that persisted/desired signals/slots/public-methods-mb list would be easy. I need to press enter because my keystrokes are lagging xD
//ok better. lol QtCreator. serializing this app's business logic "data" would be ez af tbhfam. I should use json since that .uisgd file will live right next to the class decl header and therefore probably make it into git. It is the abstract UI<-->BusinessClass "Interface" (ignore the I in "UI". I'm targetting different UI impls simultaneously!). but now the million dollar question: am I sure that all the different UI impl types will want to use the same list (the same interface)? OK YES! Again, not trying to pursuade other coders, am trying to code better myself!!! The very first sentence of the design doc that led to this project stated, using different wording, that "UI impl types should all easily have access to the same functionality that is exposed, via signals/slots/mb-public-methods (nah fuck public methods, I like KNOWING it's a slot man. it means something else entirely. it means the same as a method AND THEN SOME), on the BusinessClass". Basically I want a list of UserInterfaceActions exposed on the BusinessClass. somehow. I am pretty sure I want those UserInterfaceActions to coexist next to the lower level methods/data on that BusinessClass (they might also be public! signals/slots/properties/anything), but even this I am unsure about. Maybe I want every BusinessClass to have a QList<UserInterfaceActions*> that the ui [impls] query? I could certainly do that, but only using virtual inheritance/interfaces and am unsure if I could do it with better compile time safety like using templates can buy me. ok so the "list of user interface actions" is expressed via the connect statements...
//...[CONT'd] in that one connectToUi method. that, too, is parsable instead of keeping a .uisgd file next to my header class decl file. but ahah if it's already expressed in connectToUi connect statements, I don't- oh wait I'm talking about the 2nd+ runs, where the 'data' is no longer in memory! hmm yea I guess that .uisgd file isn't that bad an idea. I could even pre-emptively search for it in order to re-check the signals/slots from the previous run when showing the modal dialog described in the beginning of this massive (but split onto multiple lines) comment. The thing is... using that .uisgd file from a previous run to generate a different impl stub type... doesn't REALLY put TOO much pressure on you to actually USE any of the signals/slots that were put in the stub... but you ARE extremely likely to use at least some of them. I do actually think (but not 100% sure) that if your GUI does everything your CLI does 1:1, then both of them will (SHOULD!!!!!!!!!!!!! I WANT TO CODE THIS WAY!!!) use the (had:an) identical set of signals/slots!!!!!!!!!!! ok onto coding this beast
//^when running the app for the 2nd+ time (for the same OR alternate ui impl types), we should only use the .uisgd file to pre-populate the dialog asking which signals/slots the UI wants. but then that .uisgd file is modified now and keeps track of the different lists (IF THEY ARE DIFFERENT) that each ui impl type uses. if and when they use the same list, the "type" is efficiently added to the "types using this list"... errr... list (it's json shiz), rather than making a COPY OF the lists 1:1. we only copy the list if there are differences, kinda like COW except instead of a simple [atomic] counter like in Implicit Sharing, we actually keep track of WHO is using the list. this gives us best of both worlds: we EASILY use same list of "User Interface Actions" (connection statements basically xD), but we CAN use different list. meh that connetToUi class now needs multiple versions per UI? and the name can change from abstract to concrete? wtf? fffff. maybe this idea sucks and they just HAVE TO use same list (that's how it's gonna be for now at least)
int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    //TODOreq: proper UserInterfaceSkeletonGeneratorCli use
    UserInterfaceSkeletonGenerator generator;
    generator.generateUserInterfaceSkeletonFromClassDeclarationString("TODOreq", QList<QString>() << "cli" << "widget");

    return 0;
}
