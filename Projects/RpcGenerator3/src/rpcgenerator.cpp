#include "rpcgenerator.h"

#include <QTemporaryDir>
#include <QFile>
#include <QTextStream>
#include <QDir>

#include "api.h"

#define EEEEEEEEEE_RETURN_RpcGenerator(errorMessage, returnWhat) \
{ \
    emit e(errorMessage); \
    emit rpcGenerated(false); \
    return returnWhat; \
}

#define EEEEEEEEEE_RpcGenerator(errorMessage) EEEEEEEEEE_RETURN_RpcGenerator(errorMessage, )

#define NoApiCallArgs QList<ApiTypeAndVarName>()

//#define AUTO_GENERATED_RPC_CODE_SUBDIR_PREFIX ("autogeneratedrpccodefor" + api.ApiName.toLower()) //this prefix is used in my root .gitignore and quickdirtyautobackuphalper. don't change

#define PRO_COMPILATION_VERIFICATION_MAIN_SOURCE_FILENAME "compilationverification_main.cpp"

//TODOreq: "list of files to be overwritten" pre-generate-wizard. each file has a checkbox, and is checked by default. user has final say on what is overwritten. "what makes sense" is of not for us to decide. But I suppose obviously with none checked then proceeding should be impossible...
//this is hacked together as fast as possible. ugly and lots of places elegance and efficiencies can be improved (dgaf)
//TODOmb: generate matching .pri file
//TODOoptional: at the pre-generate wizard, a radio button with 2 options: "generate front-end automatically" (AutoDrilldown) and "generate front-end template only" (qFatal in methods). The overwrite policy of those front-ends should follow the business files (ie: don't ever overwrite, but regenerate if not existing). Obviously they should be able to not generate any front-end "templates" (drilldown-populated and qFatal-populed both being examples of templates (and explicitly not mentioning the fact that there's "Wt Front-End" 'types' and "Qt Front-End" 'types')) at all
//TODOoptional: relating to above^... it makes sense on a per request/response api arg to be able to specify "auto drilldown", "qFatal impl", or "none". AutoDrilldown should be the default on a pre-generate wizard showing all the api call request/response types, and selecting "qFatal impl" could/would be what you select if you already know the AutoDrilldown representation doesn't fit that specific use case (which will happen often af I'd imagine (and it not happening is the best "cache hit" (time saver) in the world xD))
//^^^Another way to do the 'drilldown/qfatal' || custom would be to use a non-pure virtual. simply override a virtual method if you want a non-drilldown (or maybe non-qfatal) gui
//TODOmb: this thought brings me waaaaaaaaay back, to "persistent object generator". Well basically I almost described it just a little ago: AutoDrilldown connected with AutoDb. If using "single" objects are being used in the response, err basically the response could be editable as a new request. FrontPageDoc could just sit there, being both a request arg source and a response arg target. those awesome "click -> line edit" widgets should of course be used :)... and yea a save button (or some sort of timeout [with visualization])
//TODOoptional: never-overwriting (TODOreq: no file should ever be overwritten unless the overwrite is definitely rpc generated. unsure about this actually) in the same way as business header/source is generating of front-end skeleton header/source for the request's response. Yes it is a whole new file to generate, but it's really just a copy/paste of an actual file, then adding it to resources and finally doing a str.replace on anything that felt the need to become templated in the meantime. I really have no idea what the fuck I'm talking about right now.
//^^FUCKING: Skeleton [GUI|WEB]FrontEnds. Obviously the requests can't be called, BUT the responses can be. I will simply put qFatal in them. Maybe later log (and/or process?) them internally as 'unimplemented response handler' and shit you know what just fucking code it to #error or whatever it is. don't let it compile unless those responses are accounted for (maybe an option to use qFatal/userStringWithSpecialTbdPercentTemplatedStringReplaceString).
//^^^And shit at this point, might as well generate a 'skeleton' .pro file(s(Web and Gui)) as well. So the creation of the application becomes "creating or at least instantiating custom tuned front-end widget-trees (QObject trees, QWidget trees, WWidget trees)
RpcGenerator::RpcGenerator(QObject *parent)
    : QObject(parent)
    , m_ApiCallbackTypesToGenerate(RpcGeneratorApiCallbackType::Qt | RpcGeneratorApiCallbackType::Web)
    , m_ApiFrontEndTypesToGenerateSkeletonCallbacksFor(RpcGeneratorApiFrontEndType::QtWidgets | RpcGeneratorApiFrontEndType::Web) //TODOreq: the web front-end type depends on the web callback type, and same goes for Qt. Maybe: having a qt or web front-end without the callback counterpart should result in an error (or at least a warning) at the time of rpc generation <-- an alternative is to simply omit anything missing a dependency callback type silently/gracefully
{ }
void RpcGenerator::addFileToWrite(FilesToWriteType *filesToWrite, Api *api, QString filePathOfFileToAdd, QString generatedFileName, bool overwriteIfExisting)
{
    if((!overwriteIfExisting) && QFile::exists(generatedFileName))
        return;
    GeneratedFile generatedFile(fileToString(filePathOfFileToAdd), generatedFileName, initialBeforeAndAfterStrings(api));
    generatedFile.replaceTemplateBeforesWithAfters();
    filesToWrite->insert(generatedFile);
}
void RpcGenerator::generateRpc()
{
    QTemporaryDir tempDir("/run/shm/RpcGenerated-");
    if(!tempDir.isValid())
        EEEEEEEEEE_RpcGenerator("unable to get temp dir")
    QString outputPath = tempDir.path();

#if 0
#if 0
    Api api("SomeBusiness");
    api.createApiCall("loginPlx", QList<ApiTypeAndVarName>() << ApiTypeAndVarName("char *", "loginUser") << ApiTypeAndVarName("QByteArray", "passwordHash"), QList<ApiTypeAndVarName>() << ApiTypeAndVarName("bool", "loginSuccess") << ApiTypeAndVarName("QString", "sessionId"));
#else //if 0
    Api api("CleanRoom");
    api.createApiCall("frontPageDefaultView", QList<ApiTypeAndVarName>() << ApiTypeAndVarName("double", "someArg0"), QList<ApiTypeAndVarName>() << ApiTypeAndVarName("QStringList", "frontPageDocs"));
#endif
#endif

#if 1
    Api api("DocumentTimeline");

    api.addPropertyToSession("bool", "LoggedIn", "false");
    api.addPropertyToSession("QString", "LoggedInUsername");

    /*TODOmb(COW obviously): api.declareDataType("Document",
                        QList<ApiTypeAndVarName>()
                            << ApiTypeAndVarName("QDateTime", "Timestamp")
                            << ApiTypeAndVarName("QString", "Username")
                            << ApiTypeAndVarName("QByteArray", "Data")
                            << ApiTypeAndVarName("QString", "LicenseIdentifier")
                        );*/

    api.createApiCall("getLatestDocuments"
                          , NoApiCallArgs
                          , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("QList<QByteArray>", "latestDocuments")
                          //, QStringList() << "<QDateTime>"
                          //, QStringList() << "<QDateTime>"
                      );
    /*api.createApiCall("getLatestDocuments"
                          , NoApiTypeAndVarNames
                          , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("QList<Document>", "latestDocuments")
                      );*/

    /*NOPE (is static): api.createApiCall("getRegistrationForm"
                            , NoApiCallArgs
                            , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("QString", "contributorLicenseAgreement")
                      );*/

    api.createApiCall("declareIntentToAttemptRegistration"
                          , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("QString", "fullName") << ApiTypeAndVarName("QString", "desiredUsername") << ApiTypeAndVarName("QString", "password") << ApiTypeAndVarName("bool", "acceptedCLA") << ApiTypeAndVarName("QString", "fullNameSignature")
                          , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("QString", "dataUserMustReciteInRegistrationAttemptVideo")
                      );

    api.createApiCall("submitRegistrationAttemptVideo"
                          , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("QString", "desiredUsername") << ApiTypeAndVarName("QString", "password") << ApiTypeAndVarName("QString", "registrationAttemptSubmissionVideoLocalFilePath")
                      );

    api.createApiCall("login"
                          , QList<ApiTypeAndVarName>() /*NOPE: request->parentSession() to get it instead (TODOreq: make an implicitly shared copy in the login business method, just to MAKE SURE that we detach from the old one that the front-end might be storing improperly (as a pointer, for example)): << ApiTypeAndVarName("DocumentTimelineSession", "documentTimelineSession")*/ << ApiTypeAndVarName("QString", "username") << ApiTypeAndVarName("QString", "password")
                          , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("DocumentTimelineSession", "documentTimelineSessionNowLoggedInIfTheApiCallWasAsuccess")
                      );

    api.createApiCall("post"
                              , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("QByteArray", "data") << ApiTypeAndVarName("QString", "licenseIdentifier")
                          );
    /*api.createApiCall("post"
                          , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("Document", "document")
                          , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("bool", "postedSuccessfully") << ApiTypeAndVarName("QByteArray", "documentKey")
                      );*/

    api.createApiCall("registrationVideoApprover_getOldestNotDoneRegistrationAttempsVideo"
                            , NoApiCallArgs
                            , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("QString", "usernameAttemptingToRegister") << ApiTypeAndVarName("QByteArray", "registrationAttemptVideo") << ApiTypeAndVarName("QString", "dataUserMustHaveRecitedInRegistrationAttemptVideo")
                      );

    api.createApiCall("registrationVideoAttemptApprover_acceptOrRejectRegistrationAttemptVideo"
                            , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("bool", "acceptIfTrue_rejectIfFalse") << ApiTypeAndVarName("QString", "usernameAttemptingToRegister")
                      );

    api.createApiCall("logout"
                          , NoApiCallArgs
                          , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("DocumentTimelineSession", "documentTimelineSessionNowLoggedOutIfTheApiCallWasAsuccess")
                      );
#endif

    QString myAutoGeneratedRpcCodeSubDirPath = outputPath + QDir::separator() + autoGeneratedRpcCodeSubDirPath(&api);
    QDir autoGeneratedRpcCodeSubDir(myAutoGeneratedRpcCodeSubDirPath);
    if((!autoGeneratedRpcCodeSubDir.exists()) && (!autoGeneratedRpcCodeSubDir.mkdir(myAutoGeneratedRpcCodeSubDirPath)))
        EEEEEEEEEE_RpcGenerator("failed to make sub-dir for rpc files")

    if(!generateRpcActual(&api, outputPath))
        EEEEEEEEEE_RpcGenerator("failed to generate")

    tempDir.setAutoRemove(false);
    emit v("successfully generated rpc to: " + outputPath); //nothing attached to v atm
    emit rpcGenerated(true, outputPath);
}
QString RpcGenerator::frontLetterToLower(const QString &stringInput)
{
    QString ret = stringInput;
    if(ret.isEmpty())
        return ret;
    QString firstLetter = ret.at(0);
    ret.remove(0, 1);
    ret.insert(0, firstLetter.toLower());
    return ret;
}
QString RpcGenerator::frontLetterToUpper(const QString &stringInput)
{
    QString ret = stringInput;
    if(ret.isEmpty())
        return ret;
    QString firstLetter = ret.at(0);
    ret.remove(0, 1);
    ret.insert(0, firstLetter.toUpper());
    return ret;
}
QString RpcGenerator::classHeaderFileName(QString apiName)
{
    return apiName.toLower() + ".h";
}
QString RpcGenerator::classSourceFileName(QString apiName)
{
    return apiName.toLower() + ".cpp";
}
QString RpcGenerator::apiCallToRequestBaseName(ApiCall *apiCall)
{
    return apiCall->ParentApi->ApiName + frontLetterToUpper(apiCall->ApiCallSlotName) + "Request";
}
QString RpcGenerator::apiCallToRequestInterfaceTypeName(ApiCall *apiCall)
{
    return "I" + apiCallToRequestBaseName(apiCall);
}
QString RpcGenerator::apiCallToRequestInterfaceHeaderInclude(ApiCall *apiCall)
{
    return "#include \"" + apiCallToRequestInterfaceTypeName(apiCall).toLower() + ".h\"";
}
QString RpcGenerator::apiCallToForwardDefinitionRawCpp(ApiCall *apiCall)
{
    return "class " + apiCallToRequestInterfaceTypeName(apiCall) + ";";
}
QString RpcGenerator::apiCallArgNamesToCommaSeparatedList(ApiCall *apiCall, bool requestIfTrue, bool makeRequestPointerFirstParameter, bool omitTypes, bool omitNames)
{
    QStringList apiCallArgsRawCpp;
    if(makeRequestPointerFirstParameter)
        apiCallArgsRawCpp.append(apiCallToRequestInterfaceTypeName(apiCall) + " *request");
    Q_FOREACH(ApiTypeAndVarName apiCallArg, (requestIfTrue ? apiCall->RequestArgs : apiCall->ResponseArgs))
    {
        apiCallArgsRawCpp.append(apiCallArgToCpp(&apiCallArg, omitTypes, omitNames));
    }
    return apiCallArgsRawCpp.join(", ");
}
QString RpcGenerator::apiCallToMethodCppSignature(ApiCall *apiCall, bool requestIfTrue, bool makeRequestPointerFirstParameter)
{
    QString ret(apiCall->ApiCallSlotName + QString(requestIfTrue ? "" : "Finished"));
    QString apiCallArgsAsCommaSeparatedList = apiCallArgNamesToCommaSeparatedList(apiCall, requestIfTrue, makeRequestPointerFirstParameter);
    bool apiCallHasArgs = !apiCall->RequestArgs.isEmpty();
    if(!requestIfTrue)
        apiCallHasArgs = !apiCall->ResponseArgs.isEmpty();
    QString commaIfThereAreApiArgs = apiCallHasArgs ? ", " : "";
    //ret.append("(bool internalError, bool apiCallSuccessFor_" + apiCall->ApiCallSlotName + ", " + apiCallArgsAsCommaSeparatedList + ")");
    QString internalErrorAndApiSuccessBool_String_IfResponse = (requestIfTrue ? "" : ("bool internalError, " + apiCall->ApiCallSlotName + "Success" + commaIfThereAreApiArgs));
    ret.append("(" + internalErrorAndApiSuccessBool_String_IfResponse + apiCallArgsAsCommaSeparatedList + ")");
    return ret;
}
QString RpcGenerator::apiCallToRawCppDeclaration(ApiCall *apiCall, bool requestIfTrue)
{
    QString ret("    void " + apiCallToMethodCppSignature(apiCall, requestIfTrue) + ";");
    return ret;
}
QString RpcGenerator::apiCallArgToCpp(ApiTypeAndVarName *apiCallArg, bool omitTypes, bool omitNames)
{
    QString ret;
    if(!omitTypes)
    {
        ret.append(apiCallArg->ApiTypeAndVarNameType);
    }
    if((!omitTypes) && (!omitNames))
    {
        if(!apiCallArg->ApiTypeAndVarNameType.endsWith(" *")) //we want points to be next to the variable name, unless the pointer is next to the type
            ret.append(" ");
    }
    if(!omitNames)
    {
        ret.append(apiCallArg->ApiTypeAndVarNameName);
    }
    return ret;
}
QString RpcGenerator::apiCallToApiDefinitionRawCpp(ApiCall *apiCall, bool requestIfTrue)
{
    QString methodSignatureForDefinition = apiCall->ParentApi->ApiName + "::" + apiCallToMethodCppSignature(apiCall, requestIfTrue);
    QString ret("void " + methodSignatureForDefinition + "\n{\n    ");
    if(requestIfTrue)
    {
        ret.append("qFatal(\"" + methodSignatureForDefinition + " not yet implemented\");");
    }
    else
    {
        //ret.append("request->respond(" + apiCallArgNamesToCommaSeparatedList(apiCall, false, false, true, false) + ");");
    }
    ret.append("\n}");
    return ret;
}
QString RpcGenerator::apiCallToApiCallRequestMethodDeclarationInSessionHeader(ApiCall *apiCall, const QString &boostOrQtCallbackArgs, QString methodApiPrefix /*whether or not to put 'Class::' in front ish*/ )
{
    QString ret;
    QString methodExcludingArgs = "void " + methodApiPrefix + "requestNew" + apiCall->ParentApi->ApiName + frontLetterToUpper(apiCall->ApiCallSlotName) + "(";
    QString maybeCommaIfApiCallHasArgs = (apiCall->RequestArgs.isEmpty() ? "" : ", ");
    ret.append(methodExcludingArgs + boostOrQtCallbackArgs + maybeCommaIfApiCallHasArgs + apiCallArgNamesToCommaSeparatedList(apiCall, true, false)); //TODOmb: considering putting the api call args in front of the [non-changing] callback variable name, BUT then there would be problems in the future if/when I implement args with default values (however, move overloads solves this (when in rome (and in this case, it's "when you're a code generator"... more overloads are CHEAP for a code generator)))
    ret.append(")");
    return ret;
}
QString RpcGenerator::apiCallToApiCallRequestMethodDefinitionInSessionSource(ApiCall *apiCall, bool trueIfQt_falseIfWt)
{
    QString ret;
    QString requseterDomainSpecificRequestType = apiCallToRequestBaseName(apiCall) + (trueIfQt_falseIfWt ? "FromQt" : "FromWt");
    QString commaMaybe = apiCall->RequestArgs.isEmpty() ? "" : ", ";
    QString requesterDomainSpecificCallbackArgsWithTypes = (trueIfQt_falseIfWt ? "QObject *objectToCallbackTo, const char *callbackSlot" : "const std::string &wtSessionId, boost::function<void (bool internalError, bool " + apiCall->ApiCallSlotName + "Success" + (apiCall->ResponseArgs.isEmpty() ? "" : ", ") + apiCallArgNamesToCommaSeparatedList(apiCall, false, false, false, true) + ")> wApplicationCallback");
    QString requesterDomainSpecificCallbackArgsWithoutTypes = (trueIfQt_falseIfWt ? "objectToCallbackTo, callbackSlot" : "wtSessionId, wApplicationCallback");
    ret.append(apiCallToApiCallRequestMethodDeclarationInSessionHeader(apiCall, requesterDomainSpecificCallbackArgsWithTypes, apiCall->ParentApi->ApiName + "Session::") + " const\n{\n    " + requseterDomainSpecificRequestType + " *request = new " + requseterDomainSpecificRequestType + "(" + frontLetterToLower(apiCall->ParentApi->ApiName) + "(), *this, " + requesterDomainSpecificCallbackArgsWithoutTypes + commaMaybe + apiCallArgNamesToCommaSeparatedList(apiCall, true, false, true, false) + ");\n    invokeRequest(request);\n}\n");
    return ret;
}
QString RpcGenerator::apiCallToConstructorInitializationCpp(ApiCall *apiCall)
{
    QString ret;
    Q_FOREACH(ApiTypeAndVarName currentApiTypeAndVarName, apiCall->RequestArgs)
    {
        QString currentApiTypeAndVarNameName = currentApiTypeAndVarName.ApiTypeAndVarNameName;
        ret.append("\n    , m_" + frontLetterToUpper(currentApiTypeAndVarNameName) + "(" + currentApiTypeAndVarNameName + ")");
    }
    return ret;
}
QString RpcGenerator::apiCallRequestArgsToRequestInterfaceHeaderDefinitions(ApiCall *apiCall)
{
    QString ret;
    if(!apiCall->RequestArgs.isEmpty())
        ret.append("\n");
    Q_FOREACH(ApiTypeAndVarName currentApiTypeAndVarName, apiCall->RequestArgs)
    {
        ret.append("\n    " + currentApiTypeAndVarName.ApiTypeAndVarNameType + " m_" + frontLetterToUpper(currentApiTypeAndVarName.ApiTypeAndVarNameName) + ";");
    }
    return ret;
}
QString RpcGenerator::apiCallRequestInterfaceArgMemberNamesWithLeadingCommaspaceIfAndArgs(ApiCall *apiCall)
{
    QString ret;
    Q_FOREACH(ApiTypeAndVarName currentApiTypeAndVarName, apiCall->RequestArgs)
    {
        ret.append(", m_" + frontLetterToUpper(currentApiTypeAndVarName.ApiTypeAndVarNameName));
    }
    return ret;
}
QString RpcGenerator::additionalIncludesForThisApiCall(ApiCall *apiCall)
{
    QStringList retList;
    Q_FOREACH(QString additionalInclude, apiCall->AdditionalIncludeForWheneverThisApiCallsRequestOrResponseArgsArePresent)
    {
        retList.append("#include " + additionalInclude);
    }
    QString ret = retList.join("\n");
    return ret;
}
QString RpcGenerator::autoGeneratedRpcCodeSubDirPath(Api *api)
{
    return "autogeneratedrpccodefor" + api->ApiName.toLower();
}
GeneratedFile RpcGenerator::generateApiInterfaceHeaderFile(Api *api, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(api);

    GeneratedFile generatedFile(fileToString(":/icleanroom.h"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(api) + "/i" + classHeaderFileName(api->ApiName), beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiInterfaceSourceFile(Api *api, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(api);

    GeneratedFile generatedFile(fileToString(":/icleanroom.cpp"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(api) + "/i" + classSourceFileName(api->ApiName), beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;

}
GeneratedFile RpcGenerator::generateApiSkeletonImplementationHeaderFile(Api *api, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(api);

    GeneratedFile generatedFile(fileToString(":/cleanroom.h"), outputDir.path() + QDir::separator() + classHeaderFileName(api->ApiName), beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiSkeletonImplementationSourceFile(Api *api, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(api);

    GeneratedFile generatedFile(fileToString(":/cleanroom.cpp"), outputDir.path() + QDir::separator() + classSourceFileName(api->ApiName), beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiRequestInterface(Api *api, QDir outputDir)
{
    //this request interface doesn't really do anything at all (since I'm a code gen), but I like it because it's sexy. It could even just be IRequest instead of IBusinessRequest (tons of design opportunities using an IRequest), but whatever. Leaving as IBusinessRequest because I don't have any compelling reason to change it [yet] (KISS)

    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(api);

    GeneratedFile generatedFile(fileToString(":/icleanroomrequest.h"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(api) + "/i" + api->ApiName.toLower() + "request.h", beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiCallRequestInterfaceHeader(ApiCall *apiCall, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(apiCall->ParentApi);
    appendApiCallBeforeAndAfterStrings(&beforeAndAfterStrings, apiCall);

    //QString commaspaceIfTheResponseHasArgs(apiCall->ResponseArgs.isEmpty() ? "" : ", ");
    beforeAndAfterStrings.insert("%COMMASPACE_MAYBE%", apiCall->ResponseArgs.isEmpty() ? "" : ", ");

    GeneratedFile generatedFile(fileToString(":/icleanroomfrontpagedefaultviewrequest.h"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(apiCall->ParentApi) + "/i" + apiCallToRequestBaseName(apiCall).toLower() + ".h", beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiCallRequestInterfaceSource(ApiCall *apiCall, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(apiCall->ParentApi);
    appendApiCallBeforeAndAfterStrings(&beforeAndAfterStrings, apiCall);

    GeneratedFile generatedFile(fileToString(":/icleanroomfrontpagedefaultviewrequest.cpp"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(apiCall->ParentApi) + "/i" + apiCallToRequestBaseName(apiCall).toLower() + ".cpp", beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiCallRequestFromQtHeader(ApiCall *apiCall, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(apiCall->ParentApi);
    appendApiCallBeforeAndAfterStrings(&beforeAndAfterStrings, apiCall);


    GeneratedFile generatedFile(fileToString(":/cleanroomfrontpagedefaultviewrequestfromqt.h"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(apiCall->ParentApi) + "/" + classHeaderFileName(apiCallToRequestBaseName(apiCall) + "fromqt"), beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiCallRequestFromQtSource(ApiCall *apiCall, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(apiCall->ParentApi);
    appendApiCallBeforeAndAfterStrings(&beforeAndAfterStrings, apiCall);

    GeneratedFile generatedFile(fileToString(":/cleanroomfrontpagedefaultviewrequestfromqt.cpp"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(apiCall->ParentApi) + "/" + classSourceFileName(apiCallToRequestBaseName(apiCall) + "fromqt"), beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiCallRequestFromWtHeader(ApiCall *apiCall, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(apiCall->ParentApi);
    appendApiCallBeforeAndAfterStrings(&beforeAndAfterStrings, apiCall);

    GeneratedFile generatedFile(fileToString(":/cleanroomfrontpagedefaultviewrequestfromwt.h"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(apiCall->ParentApi) + "/" + classHeaderFileName(apiCallToRequestBaseName(apiCall) + "fromwt"), beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiCallRequestFromWtSource(ApiCall *apiCall, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(apiCall->ParentApi);
    appendApiCallBeforeAndAfterStrings(&beforeAndAfterStrings, apiCall);

    GeneratedFile generatedFile(fileToString(":/cleanroomfrontpagedefaultviewrequestfromwt.cpp"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(apiCall->ParentApi) + "/" + classSourceFileName(apiCallToRequestBaseName(apiCall) + "fromwt"), beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiSessionHeaderFile(Api *api, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(api);

    QString apiCallMethodsOnSessionObjectHeader;
    Q_FOREACH(ApiCall apiCall, api->ApiCalls)
    {
        //FromQt overload
        apiCallMethodsOnSessionObjectHeader.append("    " + apiCallToApiCallRequestMethodDeclarationInSessionHeader(&apiCall, "QObject *objectToCallbackTo, const char *callbackSlot") + " const;\n");

        //FromWt overload
        apiCallMethodsOnSessionObjectHeader.append("    " + apiCallToApiCallRequestMethodDeclarationInSessionHeader(&apiCall, "const std::string &wtSessionId, boost::function<void (bool internalError, bool " + apiCall.ApiCallSlotName + "Success" + (apiCall.ResponseArgs.isEmpty() ? "" : ", ") + apiCallArgNamesToCommaSeparatedList(&apiCall, false, false, false, true) + ")> wApplicationCallback") + " const;\n");
    }
    beforeAndAfterStrings.insert("%API_CALL_METHODS_ON_SESSION_OBJECT_HEADER%", apiCallMethodsOnSessionObjectHeader);

    QString sessionDataAdditionalSessionPropertiesMemberDeclarations;
    QString sessionDataConstructorAdditionalSessionPropertiesCopyConstructorInitializers;
    QString sessionDataConstructorAdditionalSessionPropertiesConstructorInitializers;
    QString sessionAdditionalSessionPropertiesGettersSettersMemberDeclarationsAndDefinitions;
    Q_FOREACH(ApiSessionProperty additionalProperty, api->ApiAdditionalSessionProperties)
    {
        sessionDataAdditionalSessionPropertiesMemberDeclarations.append("\n    " + additionalProperty.PropertyTypeAndVarName.ApiTypeAndVarNameType + " " + additionalProperty.PropertyTypeAndVarName.ApiTypeAndVarNameName + ";");
        sessionDataConstructorAdditionalSessionPropertiesCopyConstructorInitializers.append("\n        , " + additionalProperty.PropertyTypeAndVarName.ApiTypeAndVarNameName + "(other." + additionalProperty.PropertyTypeAndVarName.ApiTypeAndVarNameName + ")");
        if(!additionalProperty.PropertyDefaultValueOrEmptyStringIfToDefaultConstruct.isEmpty())
        {
            sessionDataConstructorAdditionalSessionPropertiesConstructorInitializers.append("\n        , " + additionalProperty.PropertyTypeAndVarName.ApiTypeAndVarNameName + "(" + additionalProperty.PropertyDefaultValueOrEmptyStringIfToDefaultConstruct + ")");
        }
        sessionAdditionalSessionPropertiesGettersSettersMemberDeclarationsAndDefinitions.append("\n\n    " + additionalProperty.PropertyTypeAndVarName.ApiTypeAndVarNameType + " " + frontLetterToLower(additionalProperty.PropertyTypeAndVarName.ApiTypeAndVarNameName) + "() const { return d->" + additionalProperty.PropertyTypeAndVarName.ApiTypeAndVarNameName + "; }\n    void set" + frontLetterToUpper(additionalProperty.PropertyTypeAndVarName.ApiTypeAndVarNameName) + "(" + additionalProperty.PropertyTypeAndVarName.ApiTypeAndVarNameType + " " + frontLetterToLower(additionalProperty.PropertyTypeAndVarName.ApiTypeAndVarNameName) + ") { d->" + additionalProperty.PropertyTypeAndVarName.ApiTypeAndVarNameName + " = " + frontLetterToLower(additionalProperty.PropertyTypeAndVarName.ApiTypeAndVarNameName) + "; }");
    }
    beforeAndAfterStrings.insert("%SESSIONDATA_ADDITIONAL_SESSION_PROPERTIES_MEMBER_DECLARATIONS%", sessionDataAdditionalSessionPropertiesMemberDeclarations);
    beforeAndAfterStrings.insert("%SESSIONDATA_CONSTRUCTOR_ADDITIONAL_SESSION_PROPERTIES_COPY_CONSTRUCTOR_INITIALIZERS%", sessionDataConstructorAdditionalSessionPropertiesCopyConstructorInitializers);
    beforeAndAfterStrings.insert("%SESSIONDATA_CONSTRUCTOR_ADDITIONAL_SESSION_PROPERTIES_CONSTRUCTOR_INITIALIZERS%", sessionDataConstructorAdditionalSessionPropertiesConstructorInitializers);
    beforeAndAfterStrings.insert("%SESSION_ADDITIONAL_SESSION_PROPERTIES_GETTERS_SETTERS_MEMBER_DECLARATIONS_AND_DEFINITIONS%", sessionAdditionalSessionPropertiesGettersSettersMemberDeclarationsAndDefinitions);

    GeneratedFile generatedFile(fileToString(":/cleanroomsession.h"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(api) + "/" + api->ApiName.toLower() + "session.h", beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiSessionSourceFile(Api *api, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(api);

    GeneratedFile generatedFile(fileToString(":/cleanroomsession.cpp"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(api) + "/" + api->ApiName.toLower() + "session.cpp", beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateNewSessionRequestInterface(Api *api, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(api);

    GeneratedFile generatedFile(fileToString(":/icleanroomnewsessionrequest.h"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(api) + "/i" + api->ApiName.toLower() + "newsessionrequest.h", beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateNewSessionRequestFromHeaderFile(Api *api, QDir outputDir, const QString &qtOrWtFileNameSuffix)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(api);

    GeneratedFile generatedFile(fileToString(":/cleanroomnewsessionrequestfrom" + qtOrWtFileNameSuffix + ".h"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(api) + "/" + api->ApiName.toLower() + "newsessionrequestfrom" + qtOrWtFileNameSuffix + ".h", beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateNewSessionRequestFromSourceFile(Api *api, QDir outputDir, const QString &qtOrWtFileNameSuffix)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(api);

    GeneratedFile generatedFile(fileToString(":/cleanroomnewsessionrequestfrom" + qtOrWtFileNameSuffix + ".cpp"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(api) + "/" + api->ApiName.toLower() + "newsessionrequestfrom" + qtOrWtFileNameSuffix + ".cpp", beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiPriFile(Api *api, QDir outputDir, const FilesToWriteType &filesToWrite)
{
    QString priContents;
    QString autoGeneratedRpcCodeForApiSubfolderPrefix = "$$system(pwd)/" + autoGeneratedRpcCodeSubDirPath(api);
    priContents.append("INCLUDEPATH += $$system(pwd) \\\n    " + autoGeneratedRpcCodeForApiSubfolderPrefix + "\n");
    QStringList headersAppends;
    QStringList sourcesAppends;
    bool firstHeader = true;
    bool firstSource = true;
    Q_FOREACH(FileToWriteType fileToWrite, filesToWrite)
    {
        QFileInfo fileInfo(fileToWrite.GeneratedFilePath);
        QString fileSuffixLowered = fileInfo.suffix().toLower();
        if(fileSuffixLowered == "h" || fileSuffixLowered == "hpp" || fileSuffixLowered == "hxx")
        {
            QString tempCopy = autoGeneratedRpcCodeForApiSubfolderPrefix;
            if(fileInfo.fileName() == classHeaderFileName(api->ApiName))
                autoGeneratedRpcCodeForApiSubfolderPrefix = "$$system(pwd)";
            headersAppends.append(QString(firstHeader ? "HEADERS += " : "    ") + autoGeneratedRpcCodeForApiSubfolderPrefix + "/" + fileInfo.fileName()); //TODOoptimization: don't require fileinfo to get filename
            autoGeneratedRpcCodeForApiSubfolderPrefix = tempCopy;
            firstHeader = false;
        }
        if(fileSuffixLowered == "c" || fileSuffixLowered == "cpp" || fileSuffixLowered == "cxx")
        {
            QString tempCopy = autoGeneratedRpcCodeForApiSubfolderPrefix;
            if(fileInfo.fileName() == classSourceFileName(api->ApiName))
                autoGeneratedRpcCodeForApiSubfolderPrefix = "$$system(pwd)";
            sourcesAppends.append(QString(firstSource ? "SOURCES += " : "    ") + autoGeneratedRpcCodeForApiSubfolderPrefix + "/" + fileInfo.fileName());
            autoGeneratedRpcCodeForApiSubfolderPrefix = tempCopy;
            firstSource = false;
        }
    }
    QString headersAppendsString = headersAppends.join(" \\\n");
    headersAppendsString.append("\n");
    QString sourcesAppendsString = sourcesAppends.join(" \\\n");
    sourcesAppendsString.append("\n");
    priContents.append(headersAppendsString + sourcesAppendsString);

    GeneratedFile priFile(priContents, outputDir.path() + QDir::separator() + api->ApiName.toLower() + ".pri");
    return priFile;
}
GeneratedFile RpcGenerator::generateApiCompilationVerificationProFile(Api *api, QDir outputDir)
{
    QString proContents;
    QStringList includePathsList;
    QStringList headersList;
    QStringList sourcesList;
    sourcesList.append(PRO_COMPILATION_VERIFICATION_MAIN_SOURCE_FILENAME);
    QStringList additionalQtModules;
    QString removeQtGuiModuleOrQt5ConditionalWidgetsModuleAdd = "QT -= gui\n";
    QString addConsoleConfigMaybe = "CONFIG += console\n";
    QStringList additionalLibs;
    if(m_ApiFrontEndTypesToGenerateSkeletonCallbacksFor & RpcGeneratorApiFrontEndType::QtWidgets)
    {
        headersList.append("../" + api->ApiName.toLower() + "gui.h");
        sourcesList.append("../" + api->ApiName.toLower() + "gui.cpp");
        headersList.append("../" + api->ApiName.toLower() + "guiwidget.h");
        sourcesList.append("../" + api->ApiName.toLower() + "guiwidget.cpp");

        additionalQtModules.append("gui");
        removeQtGuiModuleOrQt5ConditionalWidgetsModuleAdd = "greaterThan(QT_MAJOR_VERSION, 4): QT += widgets\n";
        addConsoleConfigMaybe.clear();
        if(includePathsList.isEmpty())
            includePathsList.append("../");
    }
    if(m_ApiCallbackTypesToGenerate & RpcGeneratorApiCallbackType::Web)
        additionalLibs << "-lwt" << "-lwthttp";
    if(m_ApiFrontEndTypesToGenerateSkeletonCallbacksFor & RpcGeneratorApiFrontEndType::Web)
    {
        headersList.append("../" + api->ApiName.toLower() + "web.h");
        sourcesList.append("../" + api->ApiName.toLower() + "web.cpp");
        headersList.append("../" + api->ApiName.toLower() + "webwidget.h");
        sourcesList.append("../" + api->ApiName.toLower() + "webwidget.cpp");

        if(includePathsList.isEmpty())
            includePathsList.append("../");
    }
    QString includePaths = (includePathsList.isEmpty() ? "" : ("INCLUDEPATH += " + includePathsList.join(" \\\n    ")));
    QString headers = headersList.isEmpty() ? "" : ("HEADERS += " + headersList.join(" \\\n    "));
    QString sources = sourcesList.isEmpty() ? "" : ("SOURCES += " + sourcesList.join(" \\\n    "));
    proContents.append(
                "QT += core" + (additionalQtModules.isEmpty() ? "" : (" " + additionalQtModules.join(" "))) + "\n"
                + removeQtGuiModuleOrQt5ConditionalWidgetsModuleAdd +
                "\n"
                "TARGET = CompilationVerificationProjectFor_" + api->ApiName + "\n"
                + addConsoleConfigMaybe +
                "CONFIG -= app_bundle\n"
                "\n"
                "TEMPLATE = app\n"
                "\n"
                + includePaths + "\n\n" +
                headers +
                "\n\n"
                + sources +
                "\n\n"
                + QString("include(../") + api->ApiName.toLower() + ".pri)\n"
                "\n"
                + (additionalLibs.isEmpty() ? "" : ("LIBS += " + additionalLibs.join(" ") + "\n"))
                );

    GeneratedFile proFile(proContents, outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(api) + "/compilationverfication_" + api->ApiName.toLower() + ".pro");
    return proFile;
}
GeneratedFile RpcGenerator::generateApiCompilationVerificationMainFile(Api *api, QDir outputDir)
{
    QStringList includes;
    QStringList mainBodyInstantiations;
    QString qCoreOrRegularApplication = "QCoreApplication";;
    if(m_ApiFrontEndTypesToGenerateSkeletonCallbacksFor & RpcGeneratorApiFrontEndType::QtWidgets)
    {
        qCoreOrRegularApplication = "QApplication";
        includes << "#include \"" + api->ApiName.toLower() + "gui.h\"";
        mainBodyInstantiations << "    " + api->ApiName + "Gui gui;";
        mainBodyInstantiations << "    Q_UNUSED(gui)";
    }
    QString wServerAtTopInclude;
    if(m_ApiFrontEndTypesToGenerateSkeletonCallbacksFor & RpcGeneratorApiFrontEndType::Web)
    {
        wServerAtTopInclude = "#include <Wt/WServer>\n\n";
        includes << "#include \"" + api->ApiName.toLower() + "web.h\"";
        if(!mainBodyInstantiations.isEmpty())
            mainBodyInstantiations.append("");
        mainBodyInstantiations << "    " + api->ApiName + "Web web(argc, argv);";
        mainBodyInstantiations << "    Q_UNUSED(web)";
    }
    if(includes.isEmpty())
        includes.append("#include \"" + classHeaderFileName(api->ApiName) + "\"");
    if(mainBodyInstantiations.isEmpty())
    {
        //just instantiate the lib/business
        mainBodyInstantiations.append("    " + api->ApiName + " api;");
        mainBodyInstantiations.append("    Q_UNUSED(api)");
    }
    QString mainCppContents(
                            wServerAtTopInclude +
                            "#include <" + qCoreOrRegularApplication + ">\n\n"
                            + includes.join("\n") + "\n\n"
                            "int main(int argc, char *argv[])\n"
                            "{\n"
                                "    " + qCoreOrRegularApplication + " a(argc, argv);\n"
                                "\n"
                                + mainBodyInstantiations.join("\n") +
                                "\n\n"
                                "    QMetaObject::invokeMethod(qApp, \"quit\", Qt::QueuedConnection);\n"
                                "    return a.exec();\n"
                            "}\n"
                            );
    GeneratedFile compilationVerificationMainFile(mainCppContents, outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(api) + "/" + PRO_COMPILATION_VERIFICATION_MAIN_SOURCE_FILENAME);
    return compilationVerificationMainFile;
}
TemplateBeforeAndAfterStrings_Type RpcGenerator::initialBeforeAndAfterStrings(Api *api)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings;

    beforeAndAfterStrings.insert("%API_NAME%", api->ApiName);
    beforeAndAfterStrings.insert("%API_NAME_LOWERCASE%", api->ApiName.toLower());
    beforeAndAfterStrings.insert("%API_NAME_UPPERCASE%", api->ApiName.toUpper());
    beforeAndAfterStrings.insert("%API_AS_VARIABLE_NAME%", frontLetterToLower(api->ApiName));

    //API Calls Header Includes
    QString apiCallRequestHeaderIncludes;
    QString apiCallMethodsOnSessionObjectSource;
    Q_FOREACH(ApiCall apiCall, api->ApiCalls)
    {
        //Request includes
        apiCallRequestHeaderIncludes.append("\n#include \"" + apiCallToRequestBaseName(&apiCall).toLower() + "fromqt.h\"");
        apiCallRequestHeaderIncludes.append("\n#include \"" + apiCallToRequestBaseName(&apiCall).toLower() + "fromwt.h\"");

        //FromQt overload
        apiCallMethodsOnSessionObjectSource.append(apiCallToApiCallRequestMethodDefinitionInSessionSource(&apiCall, true));

        //FromWt overload
        apiCallMethodsOnSessionObjectSource.append(apiCallToApiCallRequestMethodDefinitionInSessionSource(&apiCall, false));
    }
    beforeAndAfterStrings.insert("%API_CALL_REQUEST_HEADER_INCLUDES%", apiCallRequestHeaderIncludes);
    beforeAndAfterStrings.insert("%API_CALL_METHODS_ON_SESSION_OBJECT_SOURCE%", apiCallMethodsOnSessionObjectSource);

    //API Calls (request slots)
    QStringList allApiCallsHeaderIncludes;
    QStringList allApiCallsDefinitions;
    QStringList allApiCallResponsesDefinitions;
    Q_FOREACH(ApiCall apiCall, api->ApiCalls)
    {
        allApiCallsHeaderIncludes.append(apiCallToRequestInterfaceHeaderInclude(&apiCall));
        allApiCallsDefinitions.append(apiCallToApiDefinitionRawCpp(&apiCall, true));
        allApiCallResponsesDefinitions.append(apiCallToApiDefinitionRawCpp(&apiCall, false));
    }
    beforeAndAfterStrings.insert("%API_CALLS_HEADER_INCLUDES%", allApiCallsHeaderIncludes.join("\n"));
    beforeAndAfterStrings.insert("%API_CALLS_DEFINITIONS%", allApiCallsDefinitions.join("\n"));
    //beforeAndAfterStrings.insert("%API_CALLS_RESPONSE_DEFINITIONS%", allApiCallResponsesDefinitions.join("\n"));

    //API Calls (request slots)
    QStringList allApiCallForwardDeclarations;
    QStringList allApiCallsDeclarationsRawCpp;
    QStringList allApiCallsPureVirtualDeclarationsRawCpp;
    Q_FOREACH(ApiCall apiCall, api->ApiCalls)
    {
        allApiCallForwardDeclarations.append(apiCallToForwardDefinitionRawCpp(&apiCall));
        allApiCallsDeclarationsRawCpp.append(apiCallToRawCppDeclaration(&apiCall, true));
        allApiCallsPureVirtualDeclarationsRawCpp.append("    virtual void " + apiCallToMethodCppSignature(&apiCall, true, true) + "=0;");
    }
    beforeAndAfterStrings.insert("%API_CALLS_FORWARD_DECLARATIONS%", allApiCallForwardDeclarations.join("\n"));
    beforeAndAfterStrings.insert("%API_CALLS_DECLARATIONS%", allApiCallsDeclarationsRawCpp.join("\n"));
    beforeAndAfterStrings.insert("%API_CALLS_PURE_VIRTUAL_DECLARATIONS%", allApiCallsPureVirtualDeclarationsRawCpp.join("\n"));
    //API Responses (response pseudo-"signals", which are both Wt and Qt compatible)
    QStringList allApiCallResponseDeclarationsRawCpp;
    Q_FOREACH(ApiCall apiCall, api->ApiCalls)
    {
        allApiCallResponseDeclarationsRawCpp.append(apiCallToRawCppDeclaration(&apiCall, false));
    }
    beforeAndAfterStrings.insert("%API_CALL_RESPONSES_DECLARATIONS%", allApiCallResponseDeclarationsRawCpp.join("\n"));

    beforeAndAfterStrings.insert("%RPC_AUTO_GENERATED_FILE_WARNING%", "//##################\n//" + tr("WARNING: DO NOT MODIFY THIS FILE!") + "\n//This file was automatically generated by Rpc Generator 3. If the rpc generator application is run again, your changes will be silently overwritten!\n//##################\n");
    beforeAndAfterStrings.insert("%RPC_AUTO_SKELETON_FILE_SUGGESTIONANDWARNING%", "//##################\n//" + tr("This file is an Rpc Generated Business Implementation Skeleton file. Changing it is allowed. If you delete this file, it will be re-generated to it's default state the next time the Rpc Generator is run. If you really want to ignore it's contents, just put the entire file's contents in an 'if 0'") + "\n//##################\n");

    QSet<QString> additionalIncludesPerApiCallDeduplicationSet;
    Q_FOREACH(const ApiCall &apiCall, api->ApiCalls)
    {
        Q_FOREACH(QString additionalInclude, apiCall.AdditionalIncludeForWheneverThisApiCallsRequestOrResponseArgsArePresent)
        {
            additionalIncludesPerApiCallDeduplicationSet.insert(additionalInclude);
        }
    }
    QStringList additionalIncludesRawCpp;
    Q_FOREACH(QString additionalInclude, additionalIncludesPerApiCallDeduplicationSet)
    {
        additionalIncludesRawCpp.append("#include " + additionalInclude);
    }
    beforeAndAfterStrings.insert("%ALL_API_CALLS_ADDITIONAL_INCLUDES_FOR_REQUEST_AND_RESPONSE_ARGS%", additionalIncludesRawCpp.join("\n"));

    QStringList apiFrontEndSkeletonCallbackMethodDeclarations;
    Q_FOREACH(ApiCall apiCall, api->ApiCalls)
    {
        QString commaSpaceIfAnyResponseArgs;
        if(!apiCall.ResponseArgs.isEmpty())
            commaSpaceIfAnyResponseArgs = ", ";
        apiFrontEndSkeletonCallbackMethodDeclarations.append("    void handle" + frontLetterToUpper(apiCall.ApiCallSlotName) + "Finished(bool internalError, bool " + frontLetterToLower(apiCall.ApiCallSlotName) + "Success" + commaSpaceIfAnyResponseArgs + apiCallArgNamesToCommaSeparatedList(&apiCall, false, false) + ");");
    }
    beforeAndAfterStrings.insert("%API_FRONTEND_SKELETON_CALLBACK_METHOD_DECLARATIONS%", apiFrontEndSkeletonCallbackMethodDeclarations.join("\n"));

    QStringList apiQtFrontEndSkeletonCallbackMethodDefinitions;
    Q_FOREACH(ApiCall apiCall, api->ApiCalls)
    {
        QString commaSpaceIfAnyResponseArgs;
        if(!apiCall.ResponseArgs.isEmpty())
            commaSpaceIfAnyResponseArgs = ", ";
        QString callbackMethodSignature = "void " + api->ApiName + "GuiWidget::handle" + frontLetterToUpper(apiCall.ApiCallSlotName) + "Finished(bool internalError, bool " + frontLetterToLower(apiCall.ApiCallSlotName) + "Success" + commaSpaceIfAnyResponseArgs + apiCallArgNamesToCommaSeparatedList(&apiCall, false, false) + ")";
        apiQtFrontEndSkeletonCallbackMethodDefinitions.append(callbackMethodSignature);
        apiQtFrontEndSkeletonCallbackMethodDefinitions.append("{");
        apiQtFrontEndSkeletonCallbackMethodDefinitions.append("    qFatal(\"callback " + callbackMethodSignature + " not yet implemented\");"); //maybe I should just do the header definition. that way, they can still compile and test/use a partially implemented api. err actually they already can xD. but still, doing header definitions only means I can STILL use the callback's signature for auto-completion (the main reason I'm doing this), BUT once they use the callback, they then would have to define it... and there's a c++ refactor action for that
        apiQtFrontEndSkeletonCallbackMethodDefinitions.append("}");
    }
    beforeAndAfterStrings.insert("%API_QTFRONTEND_SKELETON_CALLBACK_METHOD_DEFINITIONS%", apiQtFrontEndSkeletonCallbackMethodDefinitions.join("\n"));

    QStringList apiWtFrontEndSkeletonCallbackMethodDefinitions;
    Q_FOREACH(ApiCall apiCall, api->ApiCalls)
    {
        QString commaSpaceIfAnyResponseArgs;
        if(!apiCall.ResponseArgs.isEmpty())
            commaSpaceIfAnyResponseArgs = ", ";
        QString callbackMethodSignature = "void " + api->ApiName + "WebWidget::handle" + frontLetterToUpper(apiCall.ApiCallSlotName) + "Finished(bool internalError, bool " + frontLetterToLower(apiCall.ApiCallSlotName) + "Success" + commaSpaceIfAnyResponseArgs + apiCallArgNamesToCommaSeparatedList(&apiCall, false, false) + ")";
        apiWtFrontEndSkeletonCallbackMethodDefinitions.append(callbackMethodSignature);
        apiWtFrontEndSkeletonCallbackMethodDefinitions.append("{");
        apiWtFrontEndSkeletonCallbackMethodDefinitions.append("    qFatal(\"callback " + callbackMethodSignature + " not yet implemented\");"); //maybe I should just do the header definition. that way, they can still compile and test/use a partially implemented api. err actually they already can xD. but still, doing header definitions only means I can STILL use the callback's signature for auto-completion (the main reason I'm doing this), BUT once they use the callback, they then would have to define it... and there's a c++ refactor action for that
        apiWtFrontEndSkeletonCallbackMethodDefinitions.append("}");
    }
    beforeAndAfterStrings.insert("%API_WTFRONTEND_SKELETON_CALLBACK_METHOD_DEFINITIONS%", apiWtFrontEndSkeletonCallbackMethodDefinitions.join("\n"));

    return beforeAndAfterStrings;
}
void RpcGenerator::appendApiCallBeforeAndAfterStrings(TemplateBeforeAndAfterStrings_Type *beforeAndAfterStrings, ApiCall *apiCall)
{
    beforeAndAfterStrings->insert("%API_CALL_TO_REQUEST_BASE_NAME_FRONT_CHAR_TO_LOWER%", frontLetterToLower(apiCallToRequestBaseName(apiCall)));
    beforeAndAfterStrings->insert("%API_CALL_REQUEST_INTERFACE_HEADER_INCLUDE%", apiCallToRequestInterfaceHeaderInclude(apiCall));
    beforeAndAfterStrings->insert("%API_CALL_TO_REQUEST_BASE_NAME%", apiCallToRequestBaseName(apiCall));
    beforeAndAfterStrings->insert("%API_CALL_SLOT_NAME%", apiCall->ApiCallSlotName);
    beforeAndAfterStrings->insert("%API_CALL_RESPONSE_ARGS_AS_COMMA_SEPARATED_LIST_EXCLUDING_REQUEST_POINTER%", apiCallArgNamesToCommaSeparatedList(apiCall, false, false, false));
    beforeAndAfterStrings->insert("%API_CALL_RESPONSE_ARGS_AS_COMMA_SEPARATED_LIST_EXLCUDING_REQUEST_POINTER_AND_TYPENAMES%", apiCallArgNamesToCommaSeparatedList(apiCall, false, false, true));
    beforeAndAfterStrings->insert("%API_CALL_RESPONSE_ARGS_AS_COMMA_SEPARATED_LIST_EXLCUDING_REQUEST_POINTER_AND_VARNAMES%", apiCallArgNamesToCommaSeparatedList(apiCall, false, false, false, true));
    beforeAndAfterStrings->insert("%API_CALL_SLOT_NAME_TO_UPPER%", apiCall->ApiCallSlotName.toUpper());
    beforeAndAfterStrings->insert("%API_CALL_REQUEST_FROM_QT_HEADER_FILENAME%", classHeaderFileName(apiCallToRequestBaseName(apiCall) + "fromqt"));
    beforeAndAfterStrings->insert("%API_CALL_TO_REQUEST_BASE_NAME_TO_LOWERCASE%", apiCallToRequestBaseName(apiCall).toLower());
    beforeAndAfterStrings->insert("%API_CALL_ARG_TYPES_AND_NAMES_WITH_LEADING_COMMASPACE_IF_ANY_ARGS%", (apiCall->RequestArgs.isEmpty() ? "" : ", ") + apiCallArgNamesToCommaSeparatedList(apiCall, true, false));
    beforeAndAfterStrings->insert("%API_CALL_ARG_NAMES_WITH_LEADING_COMMASPACE_IF_ANY_ARGS%", (apiCall->RequestArgs.isEmpty() ? "" : ", ") + apiCallArgNamesToCommaSeparatedList(apiCall, true, false, true));
    beforeAndAfterStrings->insert("%API_CALL_ARG_CONSTRUCTOR_INITIALIZATION_LIST%", apiCallToConstructorInitializationCpp(apiCall));
    beforeAndAfterStrings->insert("%API_CALL_ARG_MEMBER_DEFINITIONS_IN_REQUEST_INTERFACE_HEADER%", apiCallRequestArgsToRequestInterfaceHeaderDefinitions(apiCall));
    beforeAndAfterStrings->insert("%API_CALL_REQUEST_INTERFACE_ARG_MEMBER_NAMES_WITH_LEADING_COMMASPACE_IF_ANY_ARGS%", apiCallRequestInterfaceArgMemberNamesWithLeadingCommaspaceIfAndArgs(apiCall));
    beforeAndAfterStrings->insert("%API_CALL_ADDITIONAL_INCLUDES_FOR_WHENEVER_THIS_API_CALLS_REQUEST_OR_RESPONSE_ARGS_ARE_PRESENT%", additionalIncludesForThisApiCall(apiCall));
    beforeAndAfterStrings->insert("%COMMASPACE_IF_RESPONSE_HAS_ANY_ARGS%", (apiCall->ResponseArgs.isEmpty() ? "" : ", "));
}
void RpcGenerator::generateApiCallFiles(FilesToWriteType *filesToWrite, ApiCall *apiCall, QDir outputDir)
{
    //Interface
    filesToWrite->insert(generateApiCallRequestInterfaceHeader(apiCall, outputDir));
    filesToWrite->insert(generateApiCallRequestInterfaceSource(apiCall, outputDir));

    //Qt Impl
    filesToWrite->insert(generateApiCallRequestFromQtHeader(apiCall, outputDir));
    filesToWrite->insert(generateApiCallRequestFromQtSource(apiCall, outputDir));

    //Wt Impl
    filesToWrite->insert(generateApiCallRequestFromWtHeader(apiCall, outputDir));
    filesToWrite->insert(generateApiCallRequestFromWtSource(apiCall, outputDir));
}
void RpcGenerator::generateApiFrontEndSkeletonImplementationFiles(FilesToWriteType *filesToWrite, Api *api, QDir outputDir, RpcGeneratorApiFrontEndType::RpcGeneratorApiFrontEndTypeEnum frontEndType)
{
    QString outputPath = outputDir.path() + QDir::separator();
    QString apiNameToLower = api->ApiName.toLower();
    if(frontEndType == RpcGeneratorApiFrontEndType::QtWidgets)
    {
        addFileToWrite(filesToWrite, api, ":/cleanroomgui.h", outputPath + apiNameToLower + "gui.h", false);
        addFileToWrite(filesToWrite, api, ":/cleanroomgui.cpp", outputPath + apiNameToLower + "gui.cpp", false);
        addFileToWrite(filesToWrite, api, ":/cleanroomguiwidget.h", outputPath + apiNameToLower + "guiwidget.h", false);
        addFileToWrite(filesToWrite, api, ":/cleanroomguiwidget.cpp", outputPath + apiNameToLower + "guiwidget.cpp", false);
    }
    else if(frontEndType == RpcGeneratorApiFrontEndType::Web)
    {
        addFileToWrite(filesToWrite, api, ":/cleanroomweb.h", outputPath + apiNameToLower + "web.h", false);
        addFileToWrite(filesToWrite, api, ":/cleanroomweb.cpp", outputPath + apiNameToLower + "web.cpp", false);
        addFileToWrite(filesToWrite, api, ":/cleanroomwebwidget.h", outputPath + apiNameToLower + "webwidget.h", false);
        addFileToWrite(filesToWrite, api, ":/cleanroomwebwidget.cpp", outputPath + apiNameToLower + "webwidget.cpp", false);
    }
}
bool RpcGenerator::generateRpcActual(Api *api, QString outputPath) //OT af: mfw "typedef QSharedPointer<IClassImpl> Class;". such easy way to use shared pointer for business objects IClassImpl _IS_ Class, but is named that way just to make the using Api more conveniently memory/lifetime managed
{
    QDir outputDir(outputPath);
    FilesToWriteType filesToWrite;

    //Main API "Business" Interface
    filesToWrite.insert(generateApiInterfaceHeaderFile(api, outputDir));
    filesToWrite.insert(generateApiInterfaceSourceFile(api, outputDir));

    //Main API "Business" Skeleton Implementation
    GeneratedFile maybeNotWriting_generatedApiSkeletontationImplementationHeaderFile = generateApiSkeletonImplementationHeaderFile(api, outputDir);
    if(!QFile::exists(maybeNotWriting_generatedApiSkeletontationImplementationHeaderFile.GeneratedFilePath))
        filesToWrite.insert(maybeNotWriting_generatedApiSkeletontationImplementationHeaderFile); //am writing skeleton header -- if you know you haven't modified the header, you can delete the stale generated header so that the fresh one is updated. Then, Qt Creator can add method skeleton code in the sourcefile using a right-click action on the method declaration in the freshly generated headerfile
    GeneratedFile maybeNotWriting_generatedApiSkeletontationImplementationSourceFile = generateApiSkeletonImplementationSourceFile(api, outputDir);;
    if(!QFile::exists(maybeNotWriting_generatedApiSkeletontationImplementationSourceFile.GeneratedFilePath))
        filesToWrite.insert(maybeNotWriting_generatedApiSkeletontationImplementationSourceFile); //am writing skeleton source

    //Api Request Interface
    filesToWrite.insert(generateApiRequestInterface(api, outputDir));

    //Per-API-Call Files
    Q_FOREACH(ApiCall apiCall, api->ApiCalls)
    {
        generateApiCallFiles(&filesToWrite, &apiCall, outputDir);
    }

    //Session
    filesToWrite.insert(generateApiSessionHeaderFile(api, outputDir));
    filesToWrite.insert(generateApiSessionSourceFile(api, outputDir));
    //New Session Request Interface
    filesToWrite.insert(generateNewSessionRequestInterface(api, outputDir));
    if(m_ApiCallbackTypesToGenerate & RpcGeneratorApiCallbackType::Qt)
    {
        //New Session Request //from Qt
        filesToWrite.insert(generateNewSessionRequestFromHeaderFile(api, outputDir, "qt"));
        filesToWrite.insert(generateNewSessionRequestFromSourceFile(api, outputDir, "qt"));
    }
    if(m_ApiCallbackTypesToGenerate & RpcGeneratorApiCallbackType::Web)
    {
        //New Session Request //from Wt
        filesToWrite.insert(generateNewSessionRequestFromHeaderFile(api, outputDir, "wt"));
        filesToWrite.insert(generateNewSessionRequestFromSourceFile(api, outputDir, "wt"));
    }

    //.pri File -- lib
    filesToWrite.insert(generateApiPriFile(api, outputDir, filesToWrite));

    //Project Compiliation Verification Files (.pro and main function in source file merely instantiating the business)
    filesToWrite.insert(generateApiCompilationVerificationProFile(api, outputDir)); //.pro
    filesToWrite.insert(generateApiCompilationVerificationMainFile(api, outputDir)); //source file with int main()


    //(Optional) Front-End Skeleton Implementation Files
    if(m_ApiFrontEndTypesToGenerateSkeletonCallbacksFor & RpcGeneratorApiFrontEndType::QtWidgets)
    {
        //Qt GUI (Widgets) Front-End Skeleton Implementation files
        generateApiFrontEndSkeletonImplementationFiles(&filesToWrite, api, outputDir, RpcGeneratorApiFrontEndType::QtWidgets);
    }
    if(m_ApiFrontEndTypesToGenerateSkeletonCallbacksFor & RpcGeneratorApiFrontEndType::Web)
    {
        //Wt Web Front-End Skeleton Implementation files
        generateApiFrontEndSkeletonImplementationFiles(&filesToWrite, api, outputDir, RpcGeneratorApiFrontEndType::Web);
    }


    if(!writeFiles(filesToWrite))
        EEEEEEEEEE_RETURN_RpcGenerator("failed to write some files", false)
    return true;
}

QString RpcGenerator::fileToString(QString filePath)
{
    QString ret;
    QFile file(filePath);
    if(file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        QTextStream stream(&file);
        ret.append(stream.readAll());
    }
    else
    {
        emit e("failed to open: " + filePath);
    }
    return ret;
}
bool RpcGenerator::writeFiles(FilesToWriteType filesToWrite)
{
    FilesToWriteIterator it(filesToWrite);
    while(it.hasNext())
    {
        const FileToWriteType currentFileToWrite = it.next();
        if(!writeFile(currentFileToWrite.GeneratedFilePath, currentFileToWrite.GeneratedFileContents))
            EEEEEEEEEE_RETURN_RpcGenerator("failed to write file: " + currentFileToWrite.GeneratedFilePath, false)
    }
    return true;
}
bool RpcGenerator::writeFile(QString filePath, QString fileContents)
{
    QFile file(filePath);
    if(!file.open(QIODevice::WriteOnly | QIODevice::Text))
        EEEEEEEEEE_RETURN_RpcGenerator("failed to open file for writing: " + filePath, false)
    QTextStream stream(&file);
    stream << fileContents;
    return true;
}
void GeneratedFile::replaceTemplateBeforesWithAfters()
{
    TemplateBeforeAndAfterStringsIterator it(TemplateBeforeAndAfterStrings);
    while(it.hasNext())
    {
        it.next();
        GeneratedFileContents.replace(it.key(), it.value());
    }
}
