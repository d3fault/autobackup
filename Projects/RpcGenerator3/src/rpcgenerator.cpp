#include "rpcgenerator.h"

#include <QTemporaryDir>
#include <QFile>
#include <QTextStream>
#include <QDir>

#include "api.h"

#define EEEEEEEEEE_RETURN_RpcGenerator(errorMessage, returnWhat) \
{ \
    emit e(errorMessage); \
    emit rpcGenerated(false); \
    return returnWhat; \
}

#define EEEEEEEEEE_RpcGenerator(errorMessage) EEEEEEEEEE_RETURN_RpcGenerator(errorMessage, )

#define NoApiCallArgs QList<ApiTypeAndVarName>()

//#define AUTO_GENERATED_RPC_CODE_SUBDIR_PREFIX ("autogeneratedrpccodefor" + api.ApiName.toLower()) //this prefix is used in my root .gitignore and quickdirtyautobackuphalper. don't change

#define PRO_COMPILATION_VERIFICATION_MAIN_SOURCE_FILENAME "compilationverificationprojectmain.cpp"

//TODOreq: "list of files to be overwritten" pre-generate-wizard. each file has a checkbox, and is checked by default. user has final say on what is overwritten. "what makes sense" is of not for us to decide. But I suppose obviously with none checked then proceeding should be impossible...
//this is hacked together as fast as possible. ugly and lots of places elegance and efficiencies can be improved (dgaf)
//TODOmb: generate matching .pri file
//TODOoptional: at the pre-generate wizard, a radio button with 2 options: "generate front-end automatically" (AutoDrilldown) and "generate front-end template only" (qFatal in methods). The overwrite policy of those front-ends should follow the business files (ie: don't ever overwrite, but regenerate if not existing). Obviously they should be able to not generate any front-end "templates" (drilldown-populated and qFatal-populed both being examples of templates (and explicitly not mentioning the fact that there's "Wt Front-End" 'types' and "Qt Front-End" 'types')) at all
//TODOoptional: relating to above^... it makes sense on a per request/response api arg to be able to specify "auto drilldown", "qFatal impl", or "none". AutoDrilldown should be the default on a pre-generate wizard showing all the api call request/response types, and selecting "qFatal impl" could/would be what you select if you already know the AutoDrilldown representation doesn't fit that specific use case (which will happen often af I'd imagine (and it not happening is the best "cache hit" (time saver) in the world xD))
//^^^Another way to do the 'drilldown/qfatal' || custom would be to use a non-pure virtual. simply override a virtual method if you want a non-drilldown (or maybe non-qfatal) gui
//TODOmb: this thought brings me waaaaaaaaay back, to "persistent object generator". Well basically I almost described it just a little ago: AutoDrilldown connected with AutoDb. If using "single" objects are being used in the response, err basically the response could be editable as a new request. FrontPageDoc could just sit there, being both a request arg source and a response arg target. those awesome "click -> line edit" widgets should of course be used :)... and yea a save button (or some sort of timeout [with visualization])
//TODOoptional: never-overwriting (TODOreq: no file should ever be overwritten unless the overwrite is definitely rpc generated. unsure about this actually) in the same way as business header/source is generating of front-end skeleton header/source for the request's response. Yes it is a whole new file to generate, but it's really just a copy/paste of an actual file, then adding it to resources and finally doing a str.replace on anything that felt the need to become templated in the meantime. I really have no idea what the fuck I'm talking about right now.
//^^FUCKING: Skeleton [GUI|WEB]FrontEnds. Obviously the requests can't be called, BUT the responses can be. I will simply put qFatal in them. Maybe later log (and/or process?) them internally as 'unimplemented response handler' and shit you know what just fucking code it to #error or whatever it is. don't let it compile unless those responses are accounted for (maybe an option to use qFatal/userStringWithSpecialTbdPercentTemplatedStringReplaceString).
//^^^And shit at this point, might as well generate a 'skeleton' .pro file(s(Web and Gui)) as well. So the creation of the application becomes "creating or at least instantiating custom tuned front-end widget-trees (QObject trees, QWidget trees, WWidget trees)
RpcGenerator::RpcGenerator(QObject *parent)
    : QObject(parent)
{ }
void RpcGenerator::generateRpc()
{
    QTemporaryDir tempDir("/run/shm/RpcGenerated-");
    if(!tempDir.isValid())
        EEEEEEEEEE_RpcGenerator("unable to get temp dir")
    QString outputPath = tempDir.path();

#if 0
#if 0
    Api api("SomeBusiness");
    api.createApiCall("loginPlx", QList<ApiTypeAndVarName>() << ApiTypeAndVarName("char *", "loginUser") << ApiTypeAndVarName("QByteArray", "passwordHash"), QList<ApiTypeAndVarName>() << ApiTypeAndVarName("bool", "loginSuccess") << ApiTypeAndVarName("QString", "sessionId"));
#else //if 0
    Api api("CleanRoom");
    api.createApiCall("frontPageDefaultView", QList<ApiTypeAndVarName>() << ApiTypeAndVarName("double", "someArg0"), QList<ApiTypeAndVarName>() << ApiTypeAndVarName("QStringList", "frontPageDocs"));
#endif
#endif

#if 1
    Api api("DocumentTimeline");

    /*TODOmb(COW obviously): api.declareDataType("Document",
                        QList<ApiTypeAndVarName>()
                            << ApiTypeAndVarName("QDateTime", "Timestamp")
                            << ApiTypeAndVarName("QString", "Username")
                            << ApiTypeAndVarName("QByteArray", "Data")
                            << ApiTypeAndVarName("QString", "LicenseIdentifier")
                        );*/

    api.createApiCall("getLatestDocuments"
                          , NoApiCallArgs
                          , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("bool", "getLatestDocumentsSuccess") << ApiTypeAndVarName("QList<QByteArray>", "latestDocuments")
                          //, QStringList() << "<QDateTime>"
                          //, QStringList() << "<QDateTime>"
                      );
    /*api.createApiCall("getLatestDocuments"
                          , NoApiTypeAndVarNames
                          , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("QList<Document>", "latestDocuments")
                      );*/

    /*NOPE (is static): api.createApiCall("getRegistrationForm"
                            , NoApiCallArgs
                            , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("QString", "contributorLicenseAgreement")
                      );*/

    api.createApiCall("declareIntentToAttemptRegistration"
                          , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("QString", "fullName") << ApiTypeAndVarName("QString", "desiredUsername") << ApiTypeAndVarName("QString", "password") << ApiTypeAndVarName("bool", "acceptedCLA") << ApiTypeAndVarName("QString", "fullNameSignature")
                          , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("bool", "intentToRegisterDeclarationSuccess") << ApiTypeAndVarName("QString", "dataUserMustReciteInRegistrationAttemptVideo")
                      );

    api.createApiCall("submitRegistrationAttemptVideo"
                          , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("QString", "desiredUsername") << ApiTypeAndVarName("QString", "password") << ApiTypeAndVarName("QString", "registrationAttemptSubmissionVideoLocalFilePath")
                          , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("bool", "registrationAttemptVideoSubmissionSuccess")
                      );

    api.createApiCall("login"
                          , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("QString", "username") << ApiTypeAndVarName("QString", "password")
                          , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("bool", "loginSuccess")
                      );

    api.createApiCall("post"
                              , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("QString", "username") << ApiTypeAndVarName("QByteArray", "data") << ApiTypeAndVarName("QString", "licenseIdentifier")
                              , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("bool", "postSuccess") << ApiTypeAndVarName("QDateTime", "timestamp") << ApiTypeAndVarName("QByteArray", "docKey_aka_docHashHex")
                              , QStringList() << "<QDateTime>"
                              //, QStringList() << "<QDateTime>"
                          );
    /*api.createApiCall("post"
                          , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("Document", "document")
                          , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("bool", "postedSuccessfully") << ApiTypeAndVarName("QByteArray", "documentKey")
                      );*/

    api.createApiCall("registrationVideoApprover_getOldestNotDoneRegistrationAttempsVideo"
                            , NoApiCallArgs
                            , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("bool", "getOldestNotDoneRegistrationAttemptVideoSuccess") << ApiTypeAndVarName("QString", "usernameAttemptingToRegister") << ApiTypeAndVarName("QByteArray", "registrationAttemptVideo") << ApiTypeAndVarName("QString", "dataUserMustHaveRecitedInRegistrationAttemptVideo")
                      );

    api.createApiCall("registrationVideoAttemptApprover_acceptOrRejectRegistrationAttemptVideo"
                            , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("bool", "acceptIfTrue_rejectIfFalse") << ApiTypeAndVarName("QString", "usernameAttemptingToRegister")
                            , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("bool", "acceptOrRejectRegistrationAttemptVideoSuccess")
                      );

    api.createApiCall("logout"
                          , NoApiCallArgs
                          , QList<ApiTypeAndVarName>() << ApiTypeAndVarName("bool", "logoutSuccess")
                      );
#endif

    QString myAutoGeneratedRpcCodeSubDirPath = outputPath + QDir::separator() + autoGeneratedRpcCodeSubDirPath(&api);
    QDir autoGeneratedRpcCodeSubDir(myAutoGeneratedRpcCodeSubDirPath);
    if(!autoGeneratedRpcCodeSubDir.mkdir(myAutoGeneratedRpcCodeSubDirPath))
        EEEEEEEEEE_RpcGenerator("failed to make sub-dir for rpc files")

    if(!generateRpcActual(&api, outputPath))
        EEEEEEEEEE_RpcGenerator("failed to generate")

    tempDir.setAutoRemove(false);
    emit o("successfully generated rpc to: " + outputPath);
    emit rpcGenerated(true, outputPath);
}
QString RpcGenerator::frontLetterToLower(const QString &stringInput)
{
    QString ret = stringInput;
    if(ret.isEmpty())
        return ret;
    QString firstLetter = ret.at(0);
    ret.remove(0, 1);
    ret.insert(0, firstLetter.toLower());
    return ret;
}
QString RpcGenerator::frontLetterToUpper(const QString &stringInput)
{
    QString ret = stringInput;
    if(ret.isEmpty())
        return ret;
    QString firstLetter = ret.at(0);
    ret.remove(0, 1);
    ret.insert(0, firstLetter.toUpper());
    return ret;
}
QString RpcGenerator::classHeaderFileName(QString apiName)
{
    return apiName.toLower() + ".h";
}
QString RpcGenerator::classSourceFileName(QString apiName)
{
    return apiName.toLower() + ".cpp";
}
QString RpcGenerator::apiCallToRequestBaseName(ApiCall *apiCall)
{
    return apiCall->ParentApi->ApiName + frontLetterToUpper(apiCall->ApiCallSlotName) + "Request";
}
QString RpcGenerator::apiCallToRequestInterfaceTypeName(ApiCall *apiCall)
{
    return "I" + apiCallToRequestBaseName(apiCall);
}
QString RpcGenerator::apiCallToRequestInterfaceHeaderInclude(ApiCall *apiCall)
{
    return "#include \"" + apiCallToRequestInterfaceTypeName(apiCall).toLower() + ".h\"";
}
QString RpcGenerator::apiCallToForwardDefinitionRawCpp(ApiCall *apiCall)
{
    return "class " + apiCallToRequestInterfaceTypeName(apiCall) + ";";
}
QString RpcGenerator::apiCallArgNamesToCommaSeparatedList(ApiCall *apiCall, bool requestIfTrue, bool makeRequestPointerFirstParameter, bool emitTypes, bool emitNames)
{
    QStringList apiCallArgsRawCpp;
    if(makeRequestPointerFirstParameter)
        apiCallArgsRawCpp.append(apiCallToRequestInterfaceTypeName(apiCall) + " *request");
    Q_FOREACH(ApiTypeAndVarName apiCallArg, (requestIfTrue ? apiCall->RequestArgs : apiCall->ResponseArgs))
    {
        apiCallArgsRawCpp.append(apiCallArgToCpp(&apiCallArg, emitTypes, emitNames));
    }
    return apiCallArgsRawCpp.join(", ");
}
QString RpcGenerator::apiCallToMethodCppSignature(ApiCall *apiCall, bool requestIfTrue, bool makeRequestPointerFirstParameter)
{
    QString ret(apiCall->ApiCallSlotName + QString(requestIfTrue ? "" : "Finished"));
    QString apiCallArgsAsCommaSeparatedList = apiCallArgNamesToCommaSeparatedList(apiCall, requestIfTrue, makeRequestPointerFirstParameter);
    bool apiCallHasArgs = !apiCall->RequestArgs.isEmpty();
    if(!requestIfTrue)
        apiCallHasArgs = !apiCall->ResponseArgs.isEmpty();
    QString commaIfThereAreApiArgs = apiCallHasArgs ? ", " : "";
    //ret.append("(bool internalError, bool apiCallSuccessFor_" + apiCall->ApiCallSlotName + ", " + apiCallArgsAsCommaSeparatedList + ")");
    ret.append("(bool internalError, " + apiCall->ApiCallSlotName + "Success" + commaIfThereAreApiArgs + apiCallArgsAsCommaSeparatedList + ")");
    return ret;
}
QString RpcGenerator::apiCallToRawCppDeclaration(ApiCall *apiCall, bool requestIfTrue)
{
    QString ret("    void " + apiCallToMethodCppSignature(apiCall, requestIfTrue) + ";");
    return ret;
}
QString RpcGenerator::apiCallArgToCpp(ApiTypeAndVarName *apiCallArg, bool emitTypes, bool emitNames)
{
    QString ret;
    if(!emitTypes)
    {
        ret.append(apiCallArg->ApiTypeAndVarNameType);
    }
    if((!emitTypes) && (!emitNames))
    {
        if(!apiCallArg->ApiTypeAndVarNameType.endsWith(" *")) //we want points to be next to the variable name, unless the pointer is next to the type
            ret.append(" ");
    }
    if(!emitNames)
    {
        ret.append(apiCallArg->ApiTypeAndVarNameName);
    }
    return ret;
}
QString RpcGenerator::apiCallToApiDefinitionRawCpp(ApiCall *apiCall, bool requestIfTrue)
{
    QString methodSignatureForDefinition = apiCall->ParentApi->ApiName + "::" + apiCallToMethodCppSignature(apiCall, requestIfTrue);
    QString ret("void " + methodSignatureForDefinition + "\n{\n    ");
    if(requestIfTrue)
    {
        ret.append("qFatal(\"" + methodSignatureForDefinition + " not yet implemented\");");
    }
    else
    {
        //ret.append("request->respond(" + apiCallArgNamesToCommaSeparatedList(apiCall, false, false, true, false) + ");");
    }
    ret.append("\n}");
    return ret;
}
QString RpcGenerator::apiCallToApiCallRequestMethodDeclarationInSessionHeader(ApiCall *apiCall, const QString &boostOrQtCallbackArgs, QString methodApiPrefix /*whether or not to put 'Class::' in front ish*/ )
{
    QString ret;
    QString methodExcludingArgs = "void " + methodApiPrefix + "requestNew" + apiCall->ParentApi->ApiName + frontLetterToUpper(apiCall->ApiCallSlotName) + "(";
    QString maybeCommaIfApiCallHasArgs = (apiCall->RequestArgs.isEmpty() ? "" : ", ");
    ret.append(methodExcludingArgs + boostOrQtCallbackArgs + maybeCommaIfApiCallHasArgs + apiCallArgNamesToCommaSeparatedList(apiCall, true, false)); //TODOmb: considering putting the api call args in front of the [non-changing] callback variable name, BUT then there would be problems in the future if/when I implement args with default values (however, move overloads solves this (when in rome (and in this case, it's "when you're a code generator"... more overloads are CHEAP for a code generator)))
    ret.append(")");
    return ret;
}
QString RpcGenerator::apiCallToApiCallRequestMethodDefinitionInSessionSource(ApiCall *apiCall, bool trueIfQt_falseIfWt)
{
    QString ret;
    QString requseterDomainSpecificRequestType = apiCallToRequestBaseName(apiCall) + (trueIfQt_falseIfWt ? "FromQt" : "FromWt");
    QString commaMaybe = apiCall->RequestArgs.isEmpty() ? "" : ", ";
    QString requesterDomainSpecificCallbackArgsWithTypes = (trueIfQt_falseIfWt ? "QObject *objectToCallbackTo, const char *callbackSlot" : "const std::string &wtSessionId, boost::function<void (" + apiCallArgNamesToCommaSeparatedList(apiCall, false, false, false, true) + ")> wApplicationCallback");
    QString requesterDomainSpecificCallbackArgsWithoutTypes = (trueIfQt_falseIfWt ? "objectToCallbackTo, callbackSlot" : "wtSessionId, wApplicationCallback");
    ret.append(apiCallToApiCallRequestMethodDeclarationInSessionHeader(apiCall, requesterDomainSpecificCallbackArgsWithTypes, apiCall->ParentApi->ApiName + "Session::") + "\n{\n    " + requseterDomainSpecificRequestType + " *request = new " + requseterDomainSpecificRequestType + "(m_" + frontLetterToUpper(apiCall->ParentApi->ApiName) + ", " + requesterDomainSpecificCallbackArgsWithoutTypes + commaMaybe + apiCallArgNamesToCommaSeparatedList(apiCall, true, false, true, false) + ");\n    invokeRequest(request);\n}\n");
    return ret;
}
QString RpcGenerator::apiCallToConstructorInitializationCpp(ApiCall *apiCall)
{
    QString ret;
    Q_FOREACH(ApiTypeAndVarName currentApiTypeAndVarName, apiCall->RequestArgs)
    {
        QString currentApiTypeAndVarNameName = currentApiTypeAndVarName.ApiTypeAndVarNameName;
        ret.append("\n    , m_" + frontLetterToUpper(currentApiTypeAndVarNameName) + "(" + currentApiTypeAndVarNameName + ")");
    }
    return ret;
}
QString RpcGenerator::apiCallRequestArgsToRequestInterfaceHeaderDefinitions(ApiCall *apiCall)
{
    QString ret;
    if(!apiCall->RequestArgs.isEmpty())
        ret.append("\nprivate:");
    Q_FOREACH(ApiTypeAndVarName currentApiTypeAndVarName, apiCall->RequestArgs)
    {
        ret.append("\n    " + currentApiTypeAndVarName.ApiTypeAndVarNameType + " m_" + frontLetterToUpper(currentApiTypeAndVarName.ApiTypeAndVarNameName) + ";");
    }
    return ret;
}
QString RpcGenerator::apiCallRequestInterfaceArgMemberNamesWithLeadingCommaspaceIfAndArgs(ApiCall *apiCall)
{
    QString ret;
    Q_FOREACH(ApiTypeAndVarName currentApiTypeAndVarName, apiCall->RequestArgs)
    {
        ret.append(", m_" + frontLetterToUpper(currentApiTypeAndVarName.ApiTypeAndVarNameName));
    }
    return ret;
}
QString RpcGenerator::additionalIncludesForThisApiCall(ApiCall *apiCall)
{
    QStringList retList;
    Q_FOREACH(QString additionalInclude, apiCall->AdditionalIncludeForWheneverThisApiCallsRequestOrResponseArgsArePresent)
    {
        retList.append("#include " + additionalInclude);
    }
    QString ret = retList.join("\n");
    return ret;
}
QString RpcGenerator::autoGeneratedRpcCodeSubDirPath(Api *api)
{
    return "autogeneratedrpccodefor" + api->ApiName.toLower();
}
GeneratedFile RpcGenerator::generateApiInterfaceHeaderFile(Api *api, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(api);

    GeneratedFile generatedFile(fileToString(":/icleanroom.h"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(api) + "/i" + classHeaderFileName(api->ApiName), beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiInterfaceSourceFile(Api *api, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(api);

    GeneratedFile generatedFile(fileToString(":/icleanroom.cpp"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(api) + "/i" + classSourceFileName(api->ApiName), beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;

}
GeneratedFile RpcGenerator::generateApiSkeletonImplementationHeaderFile(Api *api, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(api);

    GeneratedFile generatedFile(fileToString(":/cleanroom.h"), outputDir.path() + QDir::separator() + classHeaderFileName(api->ApiName), beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiSkeletonImplementationSourceFile(Api *api, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(api);

    GeneratedFile generatedFile(fileToString(":/cleanroom.cpp"), outputDir.path() + QDir::separator() + classSourceFileName(api->ApiName), beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiRequestInterface(Api *api, QDir outputDir)
{
    //this request interface doesn't really do anything at all (since I'm a code gen), but I like it because it's sexy. It could even just be IRequest instead of IBusinessRequest (tons of design opportunities using an IRequest), but whatever. Leaving as IBusinessRequest because I don't have any compelling reason to change it [yet] (KISS)

    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(api);

    GeneratedFile generatedFile(fileToString(":/icleanroomrequest.h"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(api) + "/i" + api->ApiName.toLower() + "request.h", beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiCallRequestInterfaceHeader(ApiCall *apiCall, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(apiCall->ParentApi);
    appendApiCallBeforeAndAfterStrings(&beforeAndAfterStrings, apiCall);

    //QString commaspaceIfTheResponseHasArgs(apiCall->ResponseArgs.isEmpty() ? "" : ", ");
    beforeAndAfterStrings.insert("%COMMASPACE_MAYBE%", apiCall->ResponseArgs.isEmpty() ? "" : ", ");

    GeneratedFile generatedFile(fileToString(":/icleanroomfrontpagedefaultviewrequest.h"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(apiCall->ParentApi) + "/i" + apiCallToRequestBaseName(apiCall).toLower() + ".h", beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiCallRequestInterfaceSource(ApiCall *apiCall, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(apiCall->ParentApi);
    appendApiCallBeforeAndAfterStrings(&beforeAndAfterStrings, apiCall);

    GeneratedFile generatedFile(fileToString(":/icleanroomfrontpagedefaultviewrequest.cpp"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(apiCall->ParentApi) + "/i" + apiCallToRequestBaseName(apiCall).toLower() + ".cpp", beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiCallRequestFromQtHeader(ApiCall *apiCall, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(apiCall->ParentApi);
    appendApiCallBeforeAndAfterStrings(&beforeAndAfterStrings, apiCall);


    GeneratedFile generatedFile(fileToString(":/cleanroomfrontpagedefaultviewrequestfromqt.h"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(apiCall->ParentApi) + "/" + classHeaderFileName(apiCallToRequestBaseName(apiCall) + "fromqt"), beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiCallRequestFromQtSource(ApiCall *apiCall, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(apiCall->ParentApi);
    appendApiCallBeforeAndAfterStrings(&beforeAndAfterStrings, apiCall);

    GeneratedFile generatedFile(fileToString(":/cleanroomfrontpagedefaultviewrequestfromqt.cpp"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(apiCall->ParentApi) + "/" + classSourceFileName(apiCallToRequestBaseName(apiCall) + "fromqt"), beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiCallRequestFromWtHeader(ApiCall *apiCall, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(apiCall->ParentApi);
    appendApiCallBeforeAndAfterStrings(&beforeAndAfterStrings, apiCall);

    GeneratedFile generatedFile(fileToString(":/cleanroomfrontpagedefaultviewrequestfromwt.h"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(apiCall->ParentApi) + "/" + classHeaderFileName(apiCallToRequestBaseName(apiCall) + "fromwt"), beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiCallRequestFromWtSource(ApiCall *apiCall, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(apiCall->ParentApi);
    appendApiCallBeforeAndAfterStrings(&beforeAndAfterStrings, apiCall);

    GeneratedFile generatedFile(fileToString(":/cleanroomfrontpagedefaultviewrequestfromwt.cpp"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(apiCall->ParentApi) + "/" + classSourceFileName(apiCallToRequestBaseName(apiCall) + "fromwt"), beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiSessionHeaderFile(Api *api, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(api);

    QString apiCallMethodsOnSessionObjectHeader;
    Q_FOREACH(ApiCall apiCall, api->ApiCalls)
    {
        //FromQt overload
        apiCallMethodsOnSessionObjectHeader.append("    " + apiCallToApiCallRequestMethodDeclarationInSessionHeader(&apiCall, "QObject *objectToCallbackTo, const char *callbackSlot") + ";\n");

        //FromWt overload
        apiCallMethodsOnSessionObjectHeader.append("    " + apiCallToApiCallRequestMethodDeclarationInSessionHeader(&apiCall, "const std::string &wtSessionId, boost::function<void (" + apiCallArgNamesToCommaSeparatedList(&apiCall, false, false, false, true) + ")> wApplicationCallback") + ";\n");
    }
    beforeAndAfterStrings.insert("%API_CALL_METHODS_ON_SESSION_OBJECT_HEADER%", apiCallMethodsOnSessionObjectHeader);

    GeneratedFile generatedFile(fileToString(":/cleanroomsession.h"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(api) + "/" + api->ApiName.toLower() + "session.h", beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiSessionSourceFile(Api *api, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(api);

    GeneratedFile generatedFile(fileToString(":/cleanroomsession.cpp"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(api) + "/" + api->ApiName.toLower() + "session.cpp", beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateNewSessionRequestInterface(Api *api, QDir outputDir)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(api);

    GeneratedFile generatedFile(fileToString(":/icleanroomnewsessionrequest.h"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(api) + "/i" + api->ApiName.toLower() + "newsessionrequest.h", beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateNewSessionRequestFromHeaderFile(Api *api, QDir outputDir, const QString &qtOrWtFileNameSuffix)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(api);

    GeneratedFile generatedFile(fileToString(":/cleanroomnewsessionrequestfrom" + qtOrWtFileNameSuffix + ".h"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(api) + "/" + api->ApiName.toLower() + "newsessionrequestfrom" + qtOrWtFileNameSuffix + ".h", beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateNewSessionRequestFromSourceFile(Api *api, QDir outputDir, const QString &qtOrWtFileNameSuffix)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings = initialBeforeAndAfterStrings(api);

    GeneratedFile generatedFile(fileToString(":/cleanroomnewsessionrequestfrom" + qtOrWtFileNameSuffix + ".cpp"), outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(api) + "/" + api->ApiName.toLower() + "newsessionrequestfrom" + qtOrWtFileNameSuffix + ".cpp", beforeAndAfterStrings);
    generatedFile.replaceTemplateBeforesWithAfters();
    return generatedFile;
}
GeneratedFile RpcGenerator::generateApiPriFile(Api *api, QDir outputDir, const FilesToWriteType &filesToWrite)
{
    QString priContents;
    QString autoGeneratedRpcCodeForApiSubfolderPrefix = "$$system(pwd)/" + autoGeneratedRpcCodeSubDirPath(api);
    priContents.append("INCLUDEPATH += $$system(pwd) \\\n    " + autoGeneratedRpcCodeForApiSubfolderPrefix + "\n");
    QStringList headersAppends;
    QStringList sourcesAppends;
    bool firstHeader = true;
    bool firstSource = true;
    Q_FOREACH(FileToWriteType fileToWrite, filesToWrite)
    {
        QFileInfo fileInfo(fileToWrite.GeneratedFilePath);
        QString fileSuffixLowered = fileInfo.suffix().toLower();
        if(fileSuffixLowered == "h" || fileSuffixLowered == "hpp" || fileSuffixLowered == "hxx")
        {
            QString tempCopy = autoGeneratedRpcCodeForApiSubfolderPrefix;
            if(fileInfo.fileName() == classHeaderFileName(api->ApiName))
                autoGeneratedRpcCodeForApiSubfolderPrefix = "$$system(pwd)";
            headersAppends.append(QString(firstHeader ? "HEADERS += " : "    ") + autoGeneratedRpcCodeForApiSubfolderPrefix + "/" + fileInfo.fileName()); //TODOoptimization: don't require fileinfo to get filename
            autoGeneratedRpcCodeForApiSubfolderPrefix = tempCopy;
            firstHeader = false;
        }
        if(fileSuffixLowered == "c" || fileSuffixLowered == "cpp" || fileSuffixLowered == "cxx")
        {
            QString tempCopy = autoGeneratedRpcCodeForApiSubfolderPrefix;
            if(fileInfo.fileName() == classSourceFileName(api->ApiName))
                autoGeneratedRpcCodeForApiSubfolderPrefix = "$$system(pwd)";
            sourcesAppends.append(QString(firstSource ? "SOURCES += " : "    ") + autoGeneratedRpcCodeForApiSubfolderPrefix + "/" + fileInfo.fileName());
            autoGeneratedRpcCodeForApiSubfolderPrefix = tempCopy;
            firstSource = false;
        }
    }
    QString headersAppendsString = headersAppends.join(" \\\n");
    headersAppendsString.append("\n");
    QString sourcesAppendsString = sourcesAppends.join(" \\\n");
    sourcesAppendsString.append("\n");
    priContents.append(headersAppendsString + sourcesAppendsString);

    GeneratedFile priFile(priContents, outputDir.path() + QDir::separator() + api->ApiName.toLower() + ".pri");
    return priFile;
}
GeneratedFile RpcGenerator::generateApiCompilationVerificationProFile(Api *api, QDir outputDir)
{
    QString proContents;

    proContents.append(
                "QT       += core\n"
                "QT       -= gui\n"

                "TARGET = CompilationVerificationProjectFor_" + api->ApiName + "\n"
                "CONFIG   += console\n"
                "CONFIG   -= app_bundle\n"

                "TEMPLATE = app\n"

                "HEADERS += #../" + classHeaderFileName(api->ApiName) + "\n"

                "SOURCES += " PRO_COMPILATION_VERIFICATION_MAIN_SOURCE_FILENAME " #\\\n"
                "    #../" + classSourceFileName(api->ApiName) + "\n"

                + QString("include(../") + api->ApiName.toLower() + ".pri)\n"
                "LIBS += -lwt -lwthttp\n"
                );

    GeneratedFile proFile(proContents, outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(api) + "/compilationverfication_" + api->ApiName.toLower() + ".pro");
    return proFile;
}
GeneratedFile RpcGenerator::generateApiCompilationVerificationMainFile(Api *api, QDir outputDir)
{
    QString mainCppContents(
                            "#include <QCoreApplication>\n\n#include \"" + classHeaderFileName(api->ApiName) + "\"\n\n"
                            "int main(int argc, char *argv[])\n"
                            "{\n"
                                "    QCoreApplication a(argc, argv);\n"
                                "\n"
                                "    " + api->ApiName + " api;\n"
                                "    Q_UNUSED(api)\n"
                                "\n"
                                "    QMetaObject::invokeMethod(qApp, \"quit\", Qt::QueuedConnection);\n"
                                "    return a.exec();\n"
                            "}\n"
                            );
    GeneratedFile compilationVerificationMainFile(mainCppContents, outputDir.path() + QDir::separator() + autoGeneratedRpcCodeSubDirPath(api) + "/" + PRO_COMPILATION_VERIFICATION_MAIN_SOURCE_FILENAME);
    return compilationVerificationMainFile;
}
TemplateBeforeAndAfterStrings_Type RpcGenerator::initialBeforeAndAfterStrings(Api *api)
{
    TemplateBeforeAndAfterStrings_Type beforeAndAfterStrings;

    beforeAndAfterStrings.insert("%API_NAME%", api->ApiName);
    beforeAndAfterStrings.insert("%API_NAME_LOWERCASE%", api->ApiName.toLower());
    beforeAndAfterStrings.insert("%API_NAME_UPPERCASE%", api->ApiName.toUpper());
    beforeAndAfterStrings.insert("%API_AS_VARIABLE_NAME%", frontLetterToLower(api->ApiName));

    //API Calls Header Includes
    QString apiCallRequestHeaderIncludes;
    QString apiCallMethodsOnSessionObjectSource;
    Q_FOREACH(ApiCall apiCall, api->ApiCalls)
    {
        //Request includes
        apiCallRequestHeaderIncludes.append("\n#include \"" + apiCallToRequestBaseName(&apiCall).toLower() + "fromqt.h\"");
        apiCallRequestHeaderIncludes.append("\n#include \"" + apiCallToRequestBaseName(&apiCall).toLower() + "fromwt.h\"");

        //FromQt overload
        apiCallMethodsOnSessionObjectSource.append(apiCallToApiCallRequestMethodDefinitionInSessionSource(&apiCall, true));

        //FromWt overload
        apiCallMethodsOnSessionObjectSource.append(apiCallToApiCallRequestMethodDefinitionInSessionSource(&apiCall, false));
    }
    beforeAndAfterStrings.insert("%API_CALL_REQUEST_HEADER_INCLUDES%", apiCallRequestHeaderIncludes);
    beforeAndAfterStrings.insert("%API_CALL_METHODS_ON_SESSION_OBJECT_SOURCE%", apiCallMethodsOnSessionObjectSource);

    //API Calls (request slots)
    QStringList allApiCallsHeaderIncludes;
    QStringList allApiCallsDefinitions;
    QStringList allApiCallResponsesDefinitions;
    Q_FOREACH(ApiCall apiCall, api->ApiCalls)
    {
        allApiCallsHeaderIncludes.append(apiCallToRequestInterfaceHeaderInclude(&apiCall));
        allApiCallsDefinitions.append(apiCallToApiDefinitionRawCpp(&apiCall, true));
        allApiCallResponsesDefinitions.append(apiCallToApiDefinitionRawCpp(&apiCall, false));
    }
    beforeAndAfterStrings.insert("%API_CALLS_HEADER_INCLUDES%", allApiCallsHeaderIncludes.join("\n"));
    beforeAndAfterStrings.insert("%API_CALLS_DEFINITIONS%", allApiCallsDefinitions.join("\n"));
    //beforeAndAfterStrings.insert("%API_CALLS_RESPONSE_DEFINITIONS%", allApiCallResponsesDefinitions.join("\n"));

    //API Calls (request slots)
    QStringList allApiCallForwardDeclarations;
    QStringList allApiCallsDeclarationsRawCpp;
    QStringList allApiCallsPureVirtualDeclarationsRawCpp;
    Q_FOREACH(ApiCall apiCall, api->ApiCalls)
    {
        allApiCallForwardDeclarations.append(apiCallToForwardDefinitionRawCpp(&apiCall));
        allApiCallsDeclarationsRawCpp.append(apiCallToRawCppDeclaration(&apiCall, true));
        allApiCallsPureVirtualDeclarationsRawCpp.append("    virtual void " + apiCallToMethodCppSignature(&apiCall, true, true) + "=0;");
    }
    beforeAndAfterStrings.insert("%API_CALLS_FORWARD_DECLARATIONS%", allApiCallForwardDeclarations.join("\n"));
    beforeAndAfterStrings.insert("%API_CALLS_DECLARATIONS%", allApiCallsDeclarationsRawCpp.join("\n"));
    beforeAndAfterStrings.insert("%API_CALLS_PURE_VIRTUAL_DECLARATIONS%", allApiCallsPureVirtualDeclarationsRawCpp.join("\n"));
    //API Responses (response pseudo-"signals", which are both Wt and Qt compatible)
    QStringList allApiCallResponseDeclarationsRawCpp;
    Q_FOREACH(ApiCall apiCall, api->ApiCalls)
    {
        allApiCallResponseDeclarationsRawCpp.append(apiCallToRawCppDeclaration(&apiCall, false));
    }
    beforeAndAfterStrings.insert("%API_CALL_RESPONSES_DECLARATIONS%", allApiCallResponseDeclarationsRawCpp.join("\n"));

    beforeAndAfterStrings.insert("%RPC_AUTO_GENERATED_FILE_WARNING%", "//##################\n//" + tr("WARNING: DO NOT MODIFY THIS FILE!") + "\n//This file was automatically generated by Rpc Generator 3. If the rpc generator application is run again, your changes will be silently overwritten!\n//##################\n");
    beforeAndAfterStrings.insert("%RPC_AUTO_SKELETON_FILE_SUGGESTIONANDWARNING%", "//##################\n//" + tr("This file is an Rpc Generated Business Implementation Skeleton file. Changing it is allowed. If you delete this file, it will be re-generated to it's default state the next time the Rpc Generator is run. If you really want to ignore it's contents, just put the entire file's contents in an 'if 0'") + "\n//##################\n");

    QSet<QString> additionalIncludesPerApiCallDeduplicationSet;
    Q_FOREACH(const ApiCall &apiCall, api->ApiCalls)
    {
        Q_FOREACH(QString additionalInclude, apiCall.AdditionalIncludeForWheneverThisApiCallsRequestOrResponseArgsArePresent)
        {
            additionalIncludesPerApiCallDeduplicationSet.insert(additionalInclude);
        }
    }
    QStringList additionalIncludesRawCpp;
    Q_FOREACH(QString additionalInclude, additionalIncludesPerApiCallDeduplicationSet)
    {
        additionalIncludesRawCpp.append("#include " + additionalInclude);
    }

    beforeAndAfterStrings.insert("%ALL_API_CALLS_ADDITIONAL_INCLUDES_FOR_REQUEST_AND_RESPONSE_ARGS%", additionalIncludesRawCpp.join("\n"));

    return beforeAndAfterStrings;
}
void RpcGenerator::appendApiCallBeforeAndAfterStrings(TemplateBeforeAndAfterStrings_Type *beforeAndAfterStrings, ApiCall *apiCall)
{
    beforeAndAfterStrings->insert("%API_CALL_TO_REQUEST_BASE_NAME_FRONT_CHAR_TO_LOWER%", frontLetterToLower(apiCallToRequestBaseName(apiCall)));
    beforeAndAfterStrings->insert("%API_CALL_REQUEST_INTERFACE_HEADER_INCLUDE%", apiCallToRequestInterfaceHeaderInclude(apiCall));
    beforeAndAfterStrings->insert("%API_CALL_TO_REQUEST_BASE_NAME%", apiCallToRequestBaseName(apiCall));
    beforeAndAfterStrings->insert("%API_CALL_SLOT_NAME%", apiCall->ApiCallSlotName);
    beforeAndAfterStrings->insert("%API_CALL_RESPONSE_ARGS_AS_COMMA_SEPARATED_LIST_EXCLUDING_REQUEST_POINTER%", apiCallArgNamesToCommaSeparatedList(apiCall, false, false, false));
    beforeAndAfterStrings->insert("%API_CALL_RESPONSE_ARGS_AS_COMMA_SEPARATED_LIST_EXLCUDING_REQUEST_POINTER_AND_TYPENAMES%", apiCallArgNamesToCommaSeparatedList(apiCall, false, false, true));
    beforeAndAfterStrings->insert("%API_CALL_RESPONSE_ARGS_AS_COMMA_SEPARATED_LIST_EXLCUDING_REQUEST_POINTER_AND_VARNAMES%", apiCallArgNamesToCommaSeparatedList(apiCall, false, false, false, true));
    beforeAndAfterStrings->insert("%API_CALL_SLOT_NAME_TO_UPPER%", apiCall->ApiCallSlotName.toUpper());
    beforeAndAfterStrings->insert("%API_CALL_REQUEST_FROM_QT_HEADER_FILENAME%", classHeaderFileName(apiCallToRequestBaseName(apiCall) + "fromqt"));
    beforeAndAfterStrings->insert("%API_CALL_TO_REQUEST_BASE_NAME_TO_LOWERCASE%", apiCallToRequestBaseName(apiCall).toLower());
    beforeAndAfterStrings->insert("%API_CALL_ARG_TYPES_AND_NAMES_WITH_LEADING_COMMASPACE_IF_ANY_ARGS%", (apiCall->RequestArgs.isEmpty() ? "" : ", ") + apiCallArgNamesToCommaSeparatedList(apiCall, true, false));
    beforeAndAfterStrings->insert("%API_CALL_ARG_NAMES_WITH_LEADING_COMMASPACE_IF_ANY_ARGS%", (apiCall->RequestArgs.isEmpty() ? "" : ", ") + apiCallArgNamesToCommaSeparatedList(apiCall, true, false, true));
    beforeAndAfterStrings->insert("%API_CALL_ARG_CONSTRUCTOR_INITIALIZATION_LIST%", apiCallToConstructorInitializationCpp(apiCall));
    beforeAndAfterStrings->insert("%API_CALL_ARG_MEMBER_DEFINITIONS_IN_REQUEST_INTERFACE_HEADER%", apiCallRequestArgsToRequestInterfaceHeaderDefinitions(apiCall));
    beforeAndAfterStrings->insert("%API_CALL_REQUEST_INTERFACE_ARG_MEMBER_NAMES_WITH_LEADING_COMMASPACE_IF_ANY_ARGS%", apiCallRequestInterfaceArgMemberNamesWithLeadingCommaspaceIfAndArgs(apiCall));
    beforeAndAfterStrings->insert("%API_CALL_ADDITIONAL_INCLUDES_FOR_WHENEVER_THIS_API_CALLS_REQUEST_OR_RESPONSE_ARGS_ARE_PRESENT%", additionalIncludesForThisApiCall(apiCall));
}
void RpcGenerator::writeApiCallFiles(FilesToWriteType *filesToWrite, ApiCall *apiCall, QDir outputDir)
{
    //Interface
    filesToWrite->insert(generateApiCallRequestInterfaceHeader(apiCall, outputDir));
    filesToWrite->insert(generateApiCallRequestInterfaceSource(apiCall, outputDir));

    //Qt Impl
    filesToWrite->insert(generateApiCallRequestFromQtHeader(apiCall, outputDir));
    filesToWrite->insert(generateApiCallRequestFromQtSource(apiCall, outputDir));

    //Wt Impl
    filesToWrite->insert(generateApiCallRequestFromWtHeader(apiCall, outputDir));
    filesToWrite->insert(generateApiCallRequestFromWtSource(apiCall, outputDir));
}
bool RpcGenerator::generateRpcActual(Api *api, QString outputPath) //OT af: mfw "typedef QSharedPointer<IClassImpl> Class;". such easy way to use shared pointer for business objects IClassImpl _IS_ Class, but is named that way just to make the using Api more conveniently memory/lifetime managed
{
    QDir outputDir(outputPath);
    FilesToWriteType filesToWrite;

    //Main API "Business" Interface
    filesToWrite.insert(generateApiInterfaceHeaderFile(api, outputDir));
    filesToWrite.insert(generateApiInterfaceSourceFile(api, outputDir));

    //Main API "Business" Skeleton Implementation
    GeneratedFile maybeNotWriting_generatedApiSkeletontationImplementationHeaderFile = generateApiSkeletonImplementationHeaderFile(api, outputDir);
    if(!QFile::exists(maybeNotWriting_generatedApiSkeletontationImplementationHeaderFile.GeneratedFilePath))
        filesToWrite.insert(maybeNotWriting_generatedApiSkeletontationImplementationHeaderFile); //am writing skeleton header -- if you know you haven't modified the header, you can delete the stale generated header so that the fresh one is updated. Then, Qt Creator can add method skeleton code in the sourcefile using a right-click action on the method declaration in the freshly generated headerfile
    GeneratedFile maybeNotWriting_generatedApiSkeletontationImplementationSourceFile = generateApiSkeletonImplementationSourceFile(api, outputDir);;
    if(!QFile::exists(maybeNotWriting_generatedApiSkeletontationImplementationSourceFile.GeneratedFilePath))
        filesToWrite.insert(maybeNotWriting_generatedApiSkeletontationImplementationSourceFile); //am writing skeleton source

    //Api Request Interface
    filesToWrite.insert(generateApiRequestInterface(api, outputDir));

    //Per-API-Call Objects
    Q_FOREACH(ApiCall apiCall, api->ApiCalls)
    {
        writeApiCallFiles(&filesToWrite, &apiCall, outputDir);
    }

    //Session
    filesToWrite.insert(generateApiSessionHeaderFile(api, outputDir));
    filesToWrite.insert(generateApiSessionSourceFile(api, outputDir));
    //New Session Request Interface
    filesToWrite.insert(generateNewSessionRequestInterface(api, outputDir));
    //New Session Request //from Qt
    filesToWrite.insert(generateNewSessionRequestFromHeaderFile(api, outputDir, "qt"));
    filesToWrite.insert(generateNewSessionRequestFromSourceFile(api, outputDir, "qt"));
    //New Session Request //from Wt
    filesToWrite.insert(generateNewSessionRequestFromHeaderFile(api, outputDir, "wt"));
    filesToWrite.insert(generateNewSessionRequestFromSourceFile(api, outputDir, "wt"));

    //.pri File
    filesToWrite.insert(generateApiPriFile(api, outputDir, filesToWrite));

    //Project Compiliation Verification Files (.pro and main function in source file merely instantiating the business)
    filesToWrite.insert(generateApiCompilationVerificationProFile(api, outputDir)); //.pro
    filesToWrite.insert(generateApiCompilationVerificationMainFile(api, outputDir)); //source file with int main()

    if(!writeFiles(filesToWrite))
        EEEEEEEEEE_RETURN_RpcGenerator("failed to write some files", false)
    return true;
}

QString RpcGenerator::fileToString(QString filePath)
{
    QString ret;
    QFile file(filePath);
    if(file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        QTextStream stream(&file);
        ret.append(stream.readAll());
    }
    else
    {
        emit e("failed to open: " + filePath);
    }
    return ret;
}
bool RpcGenerator::writeFiles(FilesToWriteType filesToWrite)
{
    FilesToWriteIterator it(filesToWrite);
    while(it.hasNext())
    {
        const FileToWriteType currentFileToWrite = it.next();
        if(!writeFile(currentFileToWrite.GeneratedFilePath, currentFileToWrite.GeneratedFileContents))
            EEEEEEEEEE_RETURN_RpcGenerator("failed to write file: " + currentFileToWrite.GeneratedFilePath, false)
    }
    return true;
}
bool RpcGenerator::writeFile(QString filePath, QString fileContents)
{
    QFile file(filePath);
    if(!file.open(QIODevice::WriteOnly | QIODevice::Text))
        EEEEEEEEEE_RETURN_RpcGenerator("failed to open file for writing: " + filePath, false)
    QTextStream stream(&file);
    stream << fileContents;
    return true;
}
void GeneratedFile::replaceTemplateBeforesWithAfters()
{
    TemplateBeforeAndAfterStringsIterator it(TemplateBeforeAndAfterStrings);
    while(it.hasNext())
    {
        it.next();
        GeneratedFileContents.replace(it.key(), it.value());
    }
}
