Is the reason I'm using invokeMethod or signals/slots (and private methods on a class (those definitely are run within same unit of execution)) with auto-connection because I want to keep objects thread-independent of each other? I would argue that there are times when it makes sense to maintain a unit of execution, but so long as a context is passed along, using invokeMethod or signals/slots as I do allows transparent "unit of execution + easily async'able (detach sounds like a good word too, you "async detach" it at any point that makes sense for your specific application. the underlying code is all the same, but the threads objects are running on can be organized differently for different applications (would be nice to be able to integrate QtConcurrent in some way (and probably easy come to think of it))). Considering invokeMethod or signals/slots is only 10x slower than virtual methods when used on a direct connection... AND considering the binary/source compatibility of sync-(reasonable-price-payed,but-not-as-high-as-different-thread-queued)and-async compatible objects, I guess that the invokeMethod or signals/slots + Qt::AutoConnection (the default) is already thread safe and so I make no distinction between units of executioin because I don't need to (and don't want to). For all intents and purposes, assume each signal received (or slot Invoked from someone else) is from a different unit of execution (across thread).

So with regard to DesignEqualsImplementation2: I'm going to keep the concept of "unit of execution", but only mostly for visual effect. There will be lots of separate units of execution. My 0001 example is actually incorrect, handleBarSignal is on a different unit of execution (not always, but in order to maintain thread safety between objects we need to account for that scenario and say that yes it is).

A class can have as many private "non-design-equals-generated" C/C++ classes as their private members, just as in regular coding. Associated with those "private non-designed members" (come up with better name) are include paths, linker args, and initialization routines which can be put in the constructor or other places (?which?fuckit-anywehre-i-guess), etc. Most/perhaps-all of the interaction with those "non-designed members" is done in "private methods", which of course slots can easily call IN-DESIGN. Those private methods using non-designed private members don't have to make the "state guarantee", but the slots using them inside of them do have to make that guarantee (privateFuncA can break "state guarantee" (the thing invokeMethod or signals/slots buys us), privateFuncB can fix how privateFuncA broke it, and slot0 must eventually call privateFuncB if it ever calls privateFuncA (and slot0 must do that without leaving it's unit of execution ofc, so that it keeps it's "state guarantee")

I think I over-designed 0002 and 0003, and I also think that "all initialization needs to be async" (with Qt runtime deciding what to make sync). I could be wrong about over-designing them. There might be some usefulness there.

^Since [object-on-]thread initialization _MUST_ be async, it makes more sense that all initialization is async compatible (again, Qt::AutoConnection). I guess every object needs a "readyForConnections" signal that instantiating objects listen for, connect to, and then invoke "initializePlox" on that object. HOWEVER, I can probably have the constructor take the args and each thread-helper is specific to the object (it is easy to generate a thread-helper for any object on the fly, my prior uses were trying to implement it in the C++ language itself (wanted to use MOC also, but couldn't/didn't (fail)). Generating code is much easier). Making constructors take the args doesn't buy us much but maybe does buy us ease of use from other code. What I mean is that since I'm a code gen, it doesn't matter whether I use "initialization slot later on takes the args" or "constructor takes the args"... but since I've always wanted it I should choose "constructor takes the args". Shit this idea is bullshit because I need an initialize slot no matter what because otherwise I can't listen for a delayed initialized signal (necessary for async initialization). I do sometimes think it's better to have the dumb parent=0 constructor and have the other ones be optional/helpers-only. In that case it would make sense for all my objects to have an "Initialized" (implies validity maybe?) property. There is a bool param in initialized(bool success)... so you know whether or not it really is initialized. However, this is not RAII and so sucks. How the fuck do you do RAII and and validity checking? *does search on teh nets* (btw I wrote the paragraph below earlier and then came back to append stuff to this paragraph): oh that's how, just plain and simple use-case-specific validity checking after the RAII is complete. wiki example: File file("/path.txt"); if(!file.is_open() { handle(); return; } fileIsOpenAkaValidCode(); Uhh so I think both yes both. The bool emitted in initialized (or it can/should be use case specific? opened() for file xample?) is the same as the one RAII users check. That allows both sync and async use of the class. So yes both I should do both! Whether or not to make this class is the question:
class IRaii
{
public:
	bool isInitialized() { return m_Initialized; }
protected:
	void setInitialized(bool initialized) { if(!m_Initialized && initialized) { emit initialized(true); } m_Initialized = initialized; }
private:
	bool m_Initialized = false;
protected: //signals
	initialized(bool success);
public: //slots
	void initialize(.... derp every implementer has unique args here (but worth noting that they match a constructor overload that simply calls initialize (for the RAII user))
}
//^^I think after the slot attempt, it's clear that IRaii should not exist. So that means just keep Raii in mind when designing. Come to think of it, "isInitialized" has nothing to do with "isValid". The bool that initialized emits is the validity, and it should be called isValid() etc not isInitialized etc. But I still think that because initialize can't know the args yet, it still might be pointless for IRaii to exist. Perhaps though we can/should still code gen isValid and "initialized(bool valid)" into the classes we generate (as well as the Raii constructor overload simply calling initialize (but no interface involved)). That gives me Raii and "async with error detections" combined. The design point of view might as well see the "constructor overload with the class specific args" as the main constructor, but we the code generator will know that the "initialize" slot with matching constructors is the real entry point (for any async app). Raii and signals-during-initialization are incompatible concepts by definition, but that doesn't mean async users should suffer (the signals should still exist). Also a means for Raii users to get error codes (the most recent at least, but all would be nice) could be tacked on. However a simple isValid could tell the Raii user that everything is alright (if not valid, they get the most recent error code[s] etc). No interface, auto generated yes. So _BASICALLY_ I do want to implement IRaii, BUT not formally in a C++ manner, only informally in a code-gen manner. Transparent Raii and Async is valuable.

Everything must be async (sync helpers are always a breeze to make (and the opposite holds true too (except less break downable apartable so that's why async by default is better))), but that doesn't mean everything will run async (Qt::AutoConnection).

Every object should function in a queue manner. One does not decode a video frame, one enqueues the decoding of a video frame. Luckily, Qt's event loop system already does this for you when using invokeMethod or signals/slots. You still need to be aware of it and design for it. Every slot must contain exactly one unit of execution, and the class's state must remain in tact at the end of the slot's unit of execution (so that ANY OTHER SLOT can now be invoked). Obviously, drop-down C++ can always break that rule and it is up to the user to enforce (both in their design and in their drop-down C++). TODOreq: not sure it's possible, but try to come up with a way to enforce that in both design and drop-down C++.


So what then on threads? The challenge is essentially only thread initialization. SO PERHAPS FOR NOW AND TO KISS, all initialization comes at application start. OT: Perhaps but only as an opt-in type thing: all memory allocation comes at application start (valuable as fuck, but harmful in most (had:some) server environments).
The KISS factor is weighing heavily towards that initialization-comes-at-application-start, because then I can just rely on objectOnThreadGroup's allObjectsReady thing before going forward with the application start (for example, before even showing the GUI (or letting any use case be entered))

So earlier I said "all initialization should be async", but now I'm rephrasing: all initialization should be optionally async (the sync version just uses the async version's "initialize"). Actually: all initialization should be both async and sync. Code generator makes this cheap/easy. Code generator makes you god of code.