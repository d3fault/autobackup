So I say slots must provide a "unit of execution"/state guarantee [in order to be thread safe], but since Qt5 allows any method to be a slot, I guess that applies to... *gasp*... any method. I'm fine with that, and feel like I'm rehashing standard OO verbage. "Any method must restore the state (if it modified it to begin with) before returning" sounds like something an OO book would say (and I've been trying to confirm it but without luck). Object state guarantees and thread safety guarantees are not the same, but because of Qt they have become the same :).

It's getting hard for me, even in my own code, to determine whether to call a method directly or to use a signal/slot. Generally it depends how lazy I'm feeling at the time (signal/slot is usually the better design), but thread safety is often the determining factor. It's weird and I'm kind of against that usage: that an application/use-case communicates with an object, it's communication points are declared slots... but other times on the backend that object might be communicated with via a direct [public] method call. Yes in that application/use-case it was the proper design yada yada, but the code isn't as modular as it should be. Am I saying if(public) { slot! } ?? Maybe. I of course also flip flop on the "is using direct slot invocation that much slower than direct method call" thing, but bleh I'm trying to put it out of my mind since I have no raw data to even make guesses with ("10x a virtual method). I'm not sure I'll still build the not-thread-safe C++ UML "flowchart" (is ordered) variant, but then again I actually wonder if the only REAL difference is the slot invocation statements themselves (and that a "response" is a new slot/unit-of-execution), ofc... aside from visual stuffs. Bleh in any case the thread safe version is of more value