DesignEqualsImplementationType { InternallyDesignedType, QtTypeOrCppTypeOrDefinedElsewhereType }
PROBLEMS: Even with those two enum types, there's still a problem of being able to refer to a type a million and one ways in C[++]. It doesn't make sense to have a "Boob" type and also a "const &Boob" type. The UNDERLYING type is the same (Boob), and they sure as shit wouldn't be two distinct InternallyDesignedTypes. I suppose using inheritence or something I could [re-]use the underlying types whenever needed, and just use err flagging and polymorphism to transform it to a const ref or ptr when needed (but still able to access the underlying type directly ofc). I don't think this is a huge problem for now: just use pointers everywhere xD (signals/slots + invokeMethod don't segfault if object is deleted). It would be nice to have const correctness and COW and all that shit, but functioning AT ALL obviously takes priority.

I've messed about with [editable] QCombobox and QCompleter, holy shit Qt makes that easy. Also found QToolButton and am going to change some things to use it (especially in signal/slot message editor, allowing instancing simultaneously). But damnit one problem I still haven't been able to solve [in a way I like] is differentiating (at user input collection time) between InternallyDesignedType and QtTypeOrCppTypeOrDefinedElsewhereType. When typing in that editable+auto-completed QComboBox, you can create an InternallyDesignedType by simply typing something not in the combo box, great. But how to specify a QtTypeOrCppTypeOrDefinedElsewhereType in that combo box? A shit solution would be to prefix it with "i:" (for internal (as in internal to Qt/C++ xD (fuck ambiguity))), so typing "i:QString" does not create an internally designed class called QString, but lets the app know QString is defined elsewhere. I don't like the solution, but it would work. Making this entire app function altogether isn't a challenge, it's the intuitive'ness (tm) and minizing: clicks, thinking, complexity, and redundancy (or to be more precise, automating the redundancy ;-P). I don't want to have a separate combo box for the "defined elsewhere" types, but that would work too. I could have a giant (and expandable) list of "defined elsewhere" types and check the user's input against it, but then an "int*" wouldn't match "int" etc (although I could account for that and other variants, there are too damn many in C[++] for the method to be reliable. "const int****[69] &"). Shift+Enter could signify "defined elsewhere" (plain enter = internal), but I don't like that solution either.

Umbrello differentiates between DataTypes and internally-designed-classes, and I kinda wonder what logic it uses to do it (woot tempted to go digging). I made a "bool *" attribute and it put it correctly in the DataTypes category... and then I made a "Boob" attribute and it put it in the Classes category. Then I made a "bewl *" and it _INCORRECTLY_ (?????) put it in the DataTypes category. I suppose they consider all pointer types to be DataTypes? Weird, I just now made a "const QString &" attribute and it made both the QString class and the "const QString &" DataType. I'll assume they know what they're doing by making "references and pointers" DataTypes, but I want their parser code xD. Perhaps just if contains "*" or contains "&" would suffice lololol. Oh yea arrays '[' + ']' also do that splitting, but my "contains" logic utterly fails because I'd still need to parse out the "underlying type" :-P. Damn Umbrello is GPL :(..... I sure wish I could get libclang to work AT ALL, it'd probably laugh at me with how easy the task is. But shit this experiement at least told me what I should do (do it just like Umbrello, but ofc add all the Qt types as DataTypes (or imo: "defined elsewhere" describes it better)).... now just a matter of figuring out the parsing of. Should I wrestle libclang some more or research other parsers (if only I could steal umbrellos and be done with it, *shakes fist at rms*).