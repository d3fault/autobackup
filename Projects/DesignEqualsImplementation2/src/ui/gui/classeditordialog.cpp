#include "classeditordialog.h"

#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGroupBox>
#include <QLabel>
#include <QLineEdit>
#include <QPushButton>
#include <QCheckBox>

#include "designequalsimplementationclass.h"

//modeless yet still cancelable would be best, but for now i'll settle for modal and cancelable. actually fuck that shit, the editor is going to modify the backend object directly for now (fuck the police)
ClassEditorDialog::ClassEditorDialog(DesignEqualsImplementationClass *classToEdit, QWidget *parent, Qt::WindowFlags f)
    : QDialog(parent, f)
    , m_ClassBeingEditted(classToEdit)
{
    setWindowTitle(tr("Class Editor"));

    QVBoxLayout *myLayout = new QVBoxLayout();

    QHBoxLayout *classNameRow = new QHBoxLayout();
    QLabel *classNameLabel = new QLabel(tr("Class &Name:"));
    QLineEdit *m_ClassNameLineEdit = new QLineEdit(classToEdit->ClassName);
    classNameLabel->setBuddy(m_ClassNameLineEdit);
    classNameRow->addWidget(classNameLabel);
    classNameRow->addWidget(m_ClassNameLineEdit);

    QHBoxLayout *validStateNameRow = new QHBoxLayout();
    QLabel *validStateNameLabel = new QLabel(tr("Optional state name: ")); //TODOreq: use for RAII constructor, a better name for the "initialized" signal, and the async initialize slot itself (RAII constructor calls said slot directly)
    QString validStateTooltip("Choose an arbitrary name for when this class/object is valid (open, ready, etc). \"is\" (ex: isReady) will be prepended to it:");
    validStateNameLabel->setToolTip(validStateTooltip);
    QLineEdit *m_ValidStateNameLineEdit = new QLineEdit();
    m_ValidStateNameLineEdit->setToolTip(validStateTooltip);
    validStateNameLabel->setBuddy(m_ValidStateNameLineEdit);
    validStateNameRow->addWidget(validStateNameLabel);
    validStateNameRow->addWidget(m_ValidStateNameLineEdit);

    //Quick add
    QGroupBox *quickMemberAddGroupBox = new QGroupBox(tr("&Quick Add"));
    QHBoxLayout *quickMemberAddRow = new QHBoxLayout();
    QLineEdit *m_QuickMemberAddLineEdit = new QLineEdit();
    m_QuickMemberAddLineEdit->setPlaceholderText(tr("New member signature..."));
    QPushButton *quickAddNewPropertyButton = new QPushButton(tr("Property"));
    QPushButton *quickAddNewSignalButton = new QPushButton(tr("Signal"));
    QPushButton *quickAddNewSlotButton = new QPushButton(tr("Slot"));
    quickMemberAddRow->addWidget(m_QuickMemberAddLineEdit);
    quickMemberAddRow->addWidget(quickAddNewPropertyButton);
    quickMemberAddRow->addWidget(quickAddNewSignalButton);
    quickMemberAddRow->addWidget(quickAddNewSlotButton);
    quickMemberAddGroupBox->setLayout(quickMemberAddRow);

    //Add property
    QGroupBox *addPropertyGroupBox = new QGroupBox(tr("New Property"));
    QHBoxLayout *addPropertyRow = new QHBoxLayout();
    m_AddPropertyTypeLineEdit = new QLineEdit();
    m_AddPropertyTypeLineEdit->setPlaceholderText(tr("Property Type"));
    m_AddPropertyNameLineEdit = new QLineEdit();
    m_AddPropertyNameLineEdit->setPlaceholderText(tr("Property Name"));
    m_AddPropertyReadOnlyCheckbox = new QCheckBox(tr("Read-Only"));
    m_AddPropertyNotifiesOnChangeCheckbox = new QCheckBox(tr("Notifies On Change")); //TODOreq: not sure notifies on change is applicable when read-only, so perhaps uncheck + gray it out when read only. However I am not sure about this and it makes sense that a read-only property can be changed internally by the class and still have a changed notification. I think said notification would need to be generated by Qt in that case, seeing as there is no "setBlah" method to emit the signal otherwise...
    m_AddPropertyNotifiesOnChangeCheckbox->setChecked(true);
    QPushButton *addPropertyButton = new QPushButton(tr("Add Property")); //existing classes (TODOoptional: QCombobox listing them), C++ built-in types, etc
    addPropertyButton->setToolTip(tr("Add Property of Existing Type to Class"));
    QPushButton *addPropertyAndCreateClassButton = new QPushButton(tr("Create Type + Add Property")); //TODOreq: "On the fly" class creation, JIT, whatever. Ideally we'd be able to detect whether or not the class needs to be created and to do it automagically (somewhere checking against a list of qt types, c++ types, and designed types (ideally ideally, any type within "scope" would also be checked, but that's fucking hard as fuck))
    addPropertyAndCreateClassButton->setToolTip(tr("Create Property Type + Add Property to Class"));
    addPropertyRow->addWidget(m_AddPropertyTypeLineEdit);
    addPropertyRow->addWidget(m_AddPropertyNameLineEdit);
    addPropertyRow->addWidget(m_AddPropertyReadOnlyCheckbox);
    addPropertyRow->addWidget(m_AddPropertyNotifiesOnChangeCheckbox);
    addPropertyRow->addWidget(addPropertyButton);
    addPropertyRow->addWidget(addPropertyAndCreateClassButton);
    addPropertyGroupBox->setLayout(addPropertyRow);

    //Done button
    QPushButton *doneButton = new QPushButton(tr("Done"));

    myLayout->addLayout(classNameRow);
    myLayout->addLayout(validStateNameRow);
    myLayout->addWidget(quickMemberAddGroupBox);
    myLayout->addWidget(addPropertyGroupBox);
    myLayout->addWidget(doneButton);

    setLayout(myLayout);

    connect(quickAddNewPropertyButton, SIGNAL(clicked()), this, SLOT(handleQuickAddNewPropertyButtonClicked()));
    connect(quickAddNewSignalButton, SIGNAL(clicked()), this, SLOT(handleQuickAddNewSignalButtonClicked()));
    connect(quickAddNewSlotButton, SIGNAL(clicked()), this, SLOT(handleQuickAddNewSlotButtonClicked()));

    connect(addPropertyButton, SIGNAL(clicked()), this, SLOT(handleAddPropertyButtonClicked()));

    connect(doneButton, SIGNAL(clicked()), this, SLOT(accept())); //or reject or done or close, no matter

    //reactor pattern, gui responding to our own edits <3
    connect(classToEdit, SIGNAL(propertyAdded(DesignEqualsImplementationClassProperty*)), this, SLOT(handlePropertyAdded(DesignEqualsImplementationClassProperty*)));
}
bool ClassEditorDialog::addPropertyFieldsAreSane()
{
    if(m_AddPropertyTypeLineEdit->text().trimmed().isEmpty())
    {
        emit e("Property Type must not be empty");
        return false;
    }
    if(m_AddPropertyNameLineEdit->text().trimmed().isEmpty())
    {
        emit e("Property Name must not be empty");
        return false;
    }

    //TODOreq: real sanitization, such as invalid characters etc. however the compiler does this already so i mean maybe i should just not give a shit <3

    return true;
}
void ClassEditorDialog::handleQuickAddNewPropertyButtonClicked()
{

}
void ClassEditorDialog::handleQuickAddNewSignalButtonClicked()
{

}
void ClassEditorDialog::handleQuickAddNewSlotButtonClicked()
{
    //TODOoptional: parse the method definition. i looked into using libclang, but was unable to get any of the examples working :-/. i could write a primitive basic parser, but also feel it might not be worth the effort since i'm definitely reinventing a wheel (and i know it would be limited in use and break easy)
}
void ClassEditorDialog::handleAddPropertyButtonClicked()
{
    if(addPropertyFieldsAreSane())
    {
        //signal, slot invoke, or direct method call? blah, semantecs at this point...
        m_ClassBeingEditted->createNewProperty(m_AddPropertyTypeLineEdit->text().trimmed(), m_AddPropertyNameLineEdit->text().trimmed(), m_AddPropertyReadOnlyCheckbox->isChecked(), m_AddPropertyNotifiesOnChangeCheckbox->isChecked());
        m_AddPropertyTypeLineEdit->clear();
        m_AddPropertyNameLineEdit->clear();
    }
}
void ClassEditorDialog::handlePropertyAdded(DesignEqualsImplementationClassProperty *propertyAdded)
{
    //TODOreq: visualize added property in dialog
}
