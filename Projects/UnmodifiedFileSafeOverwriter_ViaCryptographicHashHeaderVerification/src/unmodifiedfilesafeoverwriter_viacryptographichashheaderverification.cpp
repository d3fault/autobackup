#include "unmodifiedfilesafeoverwriter_viacryptographichashheaderverification.h"

#include <QFile>
#include <QFileInfo>
#include <QSaveFile>

const QCryptographicHash::Algorithm UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::CryptographicHashAlgorithm = QCryptographicHash::Sha3_256;
const QString UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::ModificationGuardHeaderPrefix = "//AutoGenerated_DO_NOT_EDIT_THIS_FILE:"; //TODOprobably: move this definition to header file! I keep getting duplicate declarations errors or somethin, fuggit. why can't _static_ members be initialized in-class DECL in new C++ :(? non-static can!

UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification(const QString &fileName, QObject *parent)
    : QBuffer(parent)
    , m_FileName(fileName)
{ }
bool UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::openFileForOverwritingAfterVerifyingItHasntBeenModified()
{
    QFile file(m_FileName);
    if(file.exists())
    {
        QFileInfo fileInfo(file);
        if(!fileInfo.isWritable())
        {
            myE("target file is not writable: " + m_FileName);
            return false;
        }

        //verify file hasn't been modified before opening for overwrite
        if(!file.open(QIODevice::ReadOnly/* | QIODevice::Text -- NOTE: we can't use QIODevice::Text because VARIATIONS of \n and \r\n would mess with our cryptographic hash calculation/verification. I could code around this TODOmb, but nahh at least not right now*/))
        {
            myE("failed to open file for reading/unmodified-verification: " + file.fileName());
            return false;
        }
        QTextStream t(&file);
        QString anError = "failed to find file modification guard header: '" + ModificationGuardHeaderPrefix + "' in file: " + file.fileName();

        /*mfw QTBUG-24367: if(!file.canReadLine())
        {
            myE(anError);
            return false;
        }*/
        QString parsedModificationGuardHeader = t.readLine();
        if(!parsedModificationGuardHeader.startsWith(ModificationGuardHeaderPrefix))
        {
            myE(anError);
            return false;
        }
        QString cryptographicHashHex = parsedModificationGuardHeader.mid(ModificationGuardHeaderPrefix.size());
        //QString fileContentsExcludingModificationGuardHeader = t.readAll();
        if(!fileContentsMatchCryptographicHash(t, cryptographicHashHex.toUtf8()))
        {
            myE("file has been modified! not overwriting file: " + file.fileName());
            return false;
        }

        //if we get here, file has been proven to NOT be modified
        return QIODevice::open(QIODevice::ReadWrite);
    }
    //else: file doesn't exist, nothing to check/verify against before [over]writing
    return QIODevice::open(QIODevice::ReadWrite);
}
bool UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::commit()
{
    //jit "rewrite" (or "prepend") the file about to be committed so it has the ModificationGuardHeaderPrefix and suffix (hash)
    qint64 origPos = pos();
    seek(0);
    QByteArray allContent = readAll();
    seek(origPos);
    QByteArray allContentHexHash = quickHexHash(allContent);

    QByteArray modificationGuardHeader = ModificationGuardHeaderPrefix.toUtf8();
    modificationGuardHeader.append(allContentHexHash);
    modificationGuardHeader.append("\n");

    allContent.prepend(modificationGuardHeader);

    QSaveFile saveFile(m_FileName);
    if(!saveFile.open(QIODevice::WriteOnly | QIODevice::Truncate))
    {
        emit e("failed to open QSaveFile for overwriting: " + m_FileName);
        return false;
    }
    saveFile.write(allContent);
    bool ret = saveFile.commit(); //TODOreq: error checking
    //if(ret)
        close();
    return ret;
}
bool UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::open(QIODevice::OpenMode flags)
{
    //TODOmb: rename openFileForOverwritingAfterVerifyingItHasntBeenModified() to open(), since it's virtual :)
    return QIODevice::open(flags);
}
void UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::close()
{
    QIODevice::close();
}
QByteArray UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::quickHexHash(const QByteArray &input)
{
    return QCryptographicHash::hash(input, CryptographicHashAlgorithm).toHex();
}
bool UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::fileContentsMatchCryptographicHash(QTextStream &t, const QByteArray &cryptographicHexHashToCheckAgainst)
{
    QCryptographicHash hasher(CryptographicHashAlgorithm);
    while(!t.atEnd())
    {
        QString currentLine = t.readLine();
        hasher.addData(currentLine.toUtf8());
    }
    QByteArray rawHash = hasher.result();
    QByteArray hexHash = rawHash.toHex();
    return (hexHash == cryptographicHexHashToCheckAgainst);
}
void UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::myE(QString msg)
{
    emit e("internal error maybe: " + errorString());
    setErrorString(msg);
    emit e(msg);
}
