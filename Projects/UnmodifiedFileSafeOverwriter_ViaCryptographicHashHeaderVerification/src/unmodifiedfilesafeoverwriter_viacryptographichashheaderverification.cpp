#include "unmodifiedfilesafeoverwriter_viacryptographichashheaderverification.h"

#include <QFile>
#include <QFileInfo>
#include <QSaveFile>

const QCryptographicHash::Algorithm UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::CryptographicHashAlgorithm = QCryptographicHash::Sha3_256;
const QString UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::ModificationGuardHeaderPrefix = "//AutoGenerated_DO_NOT_EDIT_THIS_FILE:"; //TODOprobably: move this definition to header file! I keep getting duplicate declarations errors or somethin, fuggit. why can't _static_ members be initialized in-class DECL in new C++ :(? non-static can!

//NOTE: this class is not meant to be used multiple times in a row. use 1 instance per file. the buffer is not cleared after commit()
//TODOreq: this isn't as safe as I want it to be. QIODevice::CreateOnly should be used when the file doesn't exist, and some hypothetical WriteOnly + Truncate + __Exclusive-Access__ guarantee (from OS, just like the one that QTemporaryFile gives) would be best. I'm not sure the exclusive-access thing is possible for opening an existing file, but I can fantacize :-S. and no I'm not interested in flock (but maybe I should be?)
//TODOreq: set output to ReadOnly to help the end-users not overwrite. OS will give warnings etc. this means I have to JIT set it to Writable before overwriting, then set back to ReadOnly again, but no biggy this ez af. That one "NightMux" script/project has some setReadOnly code I can copy/paste
UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification(const QString &fileName, QObject *parent)
    : QBuffer(parent)
    , m_FileName(fileName)
{ }
bool UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::openFileForOverwritingAfterVerifyingItHasntBeenModified()
{
    QFile file(m_FileName);
    if(file.exists())
    {
        QFileInfo fileInfo(file);
        if(!fileInfo.isWritable())
        {
            myE("target file is not writable: " + m_FileName);
            return false;
        }

        //verify file hasn't been modified before opening for overwrite
        if(!file.open(QIODevice::ReadOnly/* | QIODevice::Text -- NOTE: we can't use QIODevice::Text because VARIATIONS of \n and \r\n would mess with our cryptographic hash calculation/verification. I could code around this TODOmb, but nahh at least not right now. actually thinking more on this it might be just fine and dandy, since the in-memory copy always only has "\n" and never "\r\n". however there are binary files to consider I guess at least hypothetically (I almost renamed this project to UnmodifiedTextFileSafeOverwriter, implying binary is not allowed)*/))
        {
            myE("failed to open file for reading/unmodified-verification: " + file.fileName());
            return false;
        }
        QTextStream t(&file);
        QString anError = "failed to find file modification guard header: '" + ModificationGuardHeaderPrefix + "' in file: " + file.fileName();

        /*mfw QTBUG-24367: if(!file.canReadLine())
        {
            myE(anError);
            return false;
        }*/
        QString parsedModificationGuardHeader = t.readLine();
        if(!parsedModificationGuardHeader.startsWith(ModificationGuardHeaderPrefix))
        {
            myE(anError);
            return false;
        }
        QString cryptographicHashHex = parsedModificationGuardHeader.mid(ModificationGuardHeaderPrefix.size());
        //QString fileContentsExcludingModificationGuardHeader = t.readAll();
        if(!fileContentsMatchCryptographicHash(t, cryptographicHashHex.toUtf8()))
        {
            myE("file has been modified! not overwriting file: " + file.fileName());
            return false;
        }

        //if we get here, file has been proven to NOT be modified
        return QIODevice::open(QIODevice::ReadWrite);
    }
    //else: file doesn't exist, nothing to check/verify against before [over]writing
    return QIODevice::open(QIODevice::ReadWrite);
}
bool UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::commit()
{
    //jit "rewrite" (or "prepend") the file about to be committed so it has the ModificationGuardHeaderPrefix and suffix (hash)
    qint64 origPos = pos();
    seek(0);
    QByteArray allContent = readAll(); //hmm mb I should just call buffer() ? mb that's what QBuffer::readAll returns!? w/e fuggit worx don't fix it
    seek(origPos);
    QByteArray allContentHexHash = quickHexHash(allContent); //TODOoptimization: QCryptographicHash::addData

    QByteArray modificationGuardHeader = ModificationGuardHeaderPrefix.toUtf8();
    modificationGuardHeader.append(allContentHexHash);
    modificationGuardHeader.append("\n");

    allContent.prepend(modificationGuardHeader);

    QSaveFile saveFile(m_FileName);
    if(!saveFile.open(QIODevice::WriteOnly | QIODevice::Truncate))
    {
        myE("failed to open QSaveFile for overwriting: " + m_FileName);
        return false;
    }
    saveFile.write(allContent);
    bool ret = saveFile.commit();
    if(!ret)
        myE(saveFile.errorString());
    close(); //TODOreq: if commit fails, what should we do with the current buffer? TODOreq: when should I clear() (or call resize(0)) ? I guess for now this class is a "use once then destroy" class xD
    return ret;
}
bool UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::open(QIODevice::OpenMode flags)
{
    //TODOmb: rename openFileForOverwritingAfterVerifyingItHasntBeenModified() to open(), since it's virtual :)
    return QIODevice::open(flags);
}
void UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::close()
{
    QIODevice::close();
}
QByteArray UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::quickHexHash(const QByteArray &input)
{
    return QCryptographicHash::hash(input, CryptographicHashAlgorithm).toHex();
}
bool UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::fileContentsMatchCryptographicHash(QTextStream &t, const QByteArray &cryptographicHexHashToCheckAgainst)
{
    QCryptographicHash hasher(CryptographicHashAlgorithm);
    while(!t.atEnd())
    {
        QString currentLine = t.readLine();
        hasher.addData(currentLine.toUtf8());
    }
    QByteArray rawHash = hasher.result();
    QByteArray hexHash = rawHash.toHex();
    return (hexHash == cryptographicHexHashToCheckAgainst);
}
void UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::myE(QString msg)
{
    emit e("internal error maybe: " + errorString());
    setErrorString(msg);
    emit e(msg);
}
