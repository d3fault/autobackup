#include "unmodifiedfilesafeoverwriter_viacryptographichashheaderverification.h"

#include <QFile>

const QCryptographicHash::Algorithm UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::CryptographicHashAlgorithm = QCryptographicHash::Sha3_256;
const QString UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::ModificationGuardHeaderPrefix = "//AutoGenerated_DO_NOT_EDIT_THIS_FILE:"; //TODOprobably: move this definition to header file! I keep getting duplicate declarations errors or somethin, fuggit. why can't _static_ members be initialized in-class DECL in new C++ :(? non-static can!

UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification(const QString &name, QObject *parent)
    : QSaveFile(name, parent)
    //, m_FirstCallToWriteData(true)
{ }
bool UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::openFileForOverwritingAfterVerifyingItHasntBeenModified()
{
    QFile file(fileName());
    if(file.exists())
    {
        //TODOreq: verify file hasn't been modified before opening for overwrite
        if(!file.open(QIODevice::ReadOnly/* | QIODevice::Text -- NOTE: we can't use QIODevice::Text because VARIATIONS of \n and \r\n would mess with our cryptographic hash calculation/verification. I could code around this TODOmb, but nahh at least not right now*/))
        {
            myE("failed to open file for reading/unmodified-verification: " + file.fileName());
            return false;
        }

        {
            QTextStream t(&file);
            QString anError = "failed to find file modification guard header: '" + ModificationGuardHeaderPrefix + "' in file: " + file.fileName();
            if(!file.canReadLine())
            {
                myE(anError);
                return false;
            }
            QString parsedModificationGuardHeader = t.readLine();
            if(!parsedModificationGuardHeader.startsWith(ModificationGuardHeaderPrefix))
            {
                myE(anError);
                return false;
            }
            QString cryptographicHashHex = parsedModificationGuardHeader.mid(ModificationGuardHeaderPrefix.size());
            //QString fileContentsExcludingModificationGuardHeader = t.readAll();
            if(!fileContentsMatchCryptographicHash(t, cryptographicHashHex.toUtf8()))
            {
                myE("file has been modified! not overwriting file: " + file.fileName());
                return false;
            }
            //if we get here, file has been proven to NOT be modified
        }

        file.close();
        return openFileForOverwriting();
    }
    //else: file doesn't exist, nothing to worry about overwriting
    return openFileForOverwriting();
}
bool UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::confirmAndDoOverwrite()
{
    //jit "rewrite" (or "prepend") the file about to be committed so it has the ModificationGuardHeaderPrefix and suffix (hash)
    QByteArray allContent = readAll(); //TODOreq: blah QSaveFile doesn't allow 'reading', maybe I need to inherit from a QIODevice and hasA QSaveFile (only instatiated when 'commit'ing)... but now there are 2 QIODevices *shrug* :-/. mb inherit QBuffer because I want an in-memory QIODevice _until_ I commit()? I really dunno the 'proper' solution to this, but inheriting QSaveFile isn't going as smoothly as I thought it would, for various reasons I didn't even consider xD
#error "This app is fucking broken man and needs to be refactored"
    QByteArray allContentHexHash = quickHexHash(allContent);

    QByteArray modificationGuardHeader = ModificationGuardHeaderPrefix.toUtf8();
    modificationGuardHeader.append(allContentHexHash);
    modificationGuardHeader.append("\n");

    allContent.prepend(modificationGuardHeader);

    resize(0);
    write(allContent);

    //m_FirstCallToWriteData = true;
    return QSaveFile::commit(); //TODOmb: expose QSaveFile::cancelWriting() etc. if commit() was virtual this would be ezier xD
}
qint64 UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::writeData(const char *data, qint64 len)
{
#if 0 //we need to override commit() actually, because we need to hash the file's ENTIRE contents. or I guess we could override this and continually call hasher.addData? or maybe a combination of both (now changing from public QSaveFile inheritance to protected, so I can override commit() -- shit can't do that, but also need to protect users-of this class from downcasting to QSaveFile* and calling commit that way too, ffff wtf? blah commit should be virtual ffff)
    //TODOreq: on the first call to writeData, write our ModificationGuardHeaderPrefix and suffix (cryptographic hash)
    if(m_FirstCallToWriteData)
    {
        m_FirstCallToWriteData = false;
        QString modificationHeaderGuardPrefixAndDummySuffix = ModificationGuardHeaderPrefix + QString(quickHash(QByteArray("penis")));
        //hmm maybe the 'hash as we go' strat isn't good because [on first write] do I return 'len' or 'len' + modificationHeaderGuardPrefixAndDummySuffix.len()? maybe JUST overriding commit is better for this reason
    }
#endif

    return QSaveFile::writeData(data, len);
}
UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification(QObject *parent)
    : QSaveFile(parent)
{ }
QByteArray UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::quickHexHash(const QByteArray &input)
{
    return QCryptographicHash::hash(input, CryptographicHashAlgorithm).toHex();
}
bool UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::fileContentsMatchCryptographicHash(QTextStream &t, const QByteArray &cryptographicHexHashToCheckAgainst)
{
    QCryptographicHash hasher(CryptographicHashAlgorithm);
    while(t.device()->canReadLine())
    {
        QString currentLine = t.readLine();
        hasher.addData(currentLine.toUtf8());
    }
    QByteArray rawHash = hasher.result();
    QByteArray hexHash = rawHash.toHex();
    return (hexHash == cryptographicHexHashToCheckAgainst);
}
//TODOreq: making commit() private like this helps a little but doesn't protect users-of this lib downcasting 'this' to QSaveFile* and calling commit()! blah commit() needs to be virtual!
bool UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::commit()
{
    return QSaveFile::commit();
}
void UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::myE(QString msg)
{
    emit e("internal error maybe: " + errorString());
    setErrorString(msg);
    emit e(msg);
}
bool UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::openFileForOverwriting()
{
    if(!open(QIODevice::WriteOnly | QIODevice::Truncate))
    {
        myE("failed to open file for [over]writing: " + fileName());
        return false;
    }
    return true;
}
