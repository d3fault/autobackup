#include "unmodifiedfilesafeoverwriter_viacryptographichashheaderverification.h"

#include <QFile>
#include <QFileInfo>
#include <QSaveFile>

const QByteArray UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::ModificationGuardHeaderPrefix = "//AutoGenerated_DO_NOT_EDIT_THIS_FILE:"; //TODOprobably: move this definition to header file! I keep getting duplicate declarations errors or somethin, fuggit. why can't _static_ members be initialized in-class DECL in new C++ :(? non-static can!

//TODOreq: this isn't as safe as I want it to be. QIODevice::CreateOnly should be used when the file doesn't exist, and some hypothetical WriteOnly + Truncate + __Exclusive-Access__ guarantee (from OS, just like the one that QTemporaryFile gives) would be best. I'm not sure the exclusive-access thing is possible for opening an existing file, but I can fantacize :-S. and no I'm not interested in flock (but maybe I should be?)
//TODOreq: set output to ReadOnly to help the end-users not overwrite. OS will give warnings etc. this means I have to JIT set it to Writable before overwriting, then set back to ReadOnly again, but no biggy this ez af. That one "NightMux" script/project has some setReadOnly code I can copy/paste
//TO DOnereq: change hex -> b64 for the hash. because we're "storing it as ascii" (utf-8, but still). actually you know I'm not entirely sure I give a fuck: most (had:the) autogen'd files aren't persisted anyways. I'd argue that there is no reason for ANY autogen'd code to be persisted, ever. if you are a good coder, you never need any to be. I mean autogen'd in the "you leave that file unmodified" sense, UserInterfaceSkeletonGenerator still saves me boatloads of time by generating BOILERPLATE. I don't use this UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification with that ui boilerplate that UserInterfaceSkeletonGenerator generated, which I _TAKE OVER_ as my core application ui code (and soon UISG will also spit out skeleton business code because why not)
UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification(const QString &fileName, QObject *parent)
    : QIODevice(parent)
    , m_FirstCallToWriteData(true)
    , m_SaveFile(new QSaveFile(fileName, this))
    , m_Hasher(QCryptographicHash::Sha3_256)
{
    m_Hasher.addData(QByteArray("penis"));
    DummyCryptographicHashForSizingPurposes = getHasherResultEncoded();
    m_Hasher.reset();
}
bool UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::commit()
{
    qint64 myPos = m_SaveFile->pos(); //save pos

    m_SaveFile->seek(0 + ModificationGuardHeaderPrefix.size());
    qint64 numWritten = m_SaveFile->write(getHasherResultEncoded());
    //we already wrote the newline on the first go. we're only now filling in the Dummy hash with our actual calculated one

    m_SaveFile->seek(myPos); //restore pos

    if(numWritten != DummyCryptographicHashForSizingPurposes.size())
    {
        if(numWritten == -1)
            qCritical("QSaveFile gave write error");
        qFatal("can't seek to 0 and rewrite cryptographic hash header");
        return false;
    }

    bool ret = m_SaveFile->commit();
    if(ret)
    {
        //after every successful commit:
        m_FirstCallToWriteData = true;
        m_Hasher.reset();
        close();
    }
    return ret;
}
bool UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::open(OpenMode weAlwaysOpenInWriteOnlyTruncateNoMatterWhat)
{
    Q_UNUSED(weAlwaysOpenInWriteOnlyTruncateNoMatterWhat)
    QFile file(m_SaveFile->fileName()); //m_SaveFile is not yet opened, but our constructor set up the filename already
    if(file.exists())
    {
        QFileInfo fileInfo(file);
        if(!fileInfo.isWritable())
        {
            myE("target file is not writable: " + m_SaveFile->fileName());
            return false;
        }

        //verify file hasn't been modified before opening for overwrite
        if(!file.open(QIODevice::ReadOnly/* | QIODevice::Text -- NOTE: we can't use QIODevice::Text because VARIATIONS of \n and \r\n would mess with our cryptographic hash calculation/verification. I could code around this TODOmb, but nahh at least not right now. actually thinking more on this it might be just fine and dandy, since the in-memory copy always only has "\n" and never "\r\n". however there are binary files to consider I guess at least hypothetically (I almost renamed this project to UnmodifiedTextFileSafeOverwriter, implying binary is not allowed)*/))
        {
            myE("failed to open file for reading/unmodified-verification: " + file.fileName());
            return false;
        }
        QTextStream t(&file);
        QString anError = "failed to find file modification guard header: '" + ModificationGuardHeaderPrefix + "' in file: " + file.fileName();

        /*mfw QTBUG-24367: if(!file.canReadLine())
        {
            myE(anError);
            return false;
        }*/
        QString parsedModificationGuardHeader = t.readLine();
        if(!parsedModificationGuardHeader.startsWith(ModificationGuardHeaderPrefix))
        {
            myE(anError);
            return false;
        }
        QString cryptographicHashHex = parsedModificationGuardHeader.mid(ModificationGuardHeaderPrefix.size());
        //QString fileContentsExcludingModificationGuardHeader = t.readAll();
        if(!fileContentsMatchCryptographicHash(t, cryptographicHashHex.toUtf8()))
        {
            myE("file has been modified! not overwriting file: " + file.fileName());
            return false;
        }

        //if we get here, file has been proven to NOT be modified
        return myActualOpenForWriting();
    }
    //else: file doesn't exist, nothing to check/verify against before [over]writing
    return myActualOpenForWriting();
}
void UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::close()
{
    QIODevice::close();
}
bool UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::seek(qint64 pos)
{
    Q_UNUSED(pos)
    qWarning("UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::seek not supported");
    return false;
}
qint64 UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::readData(char *data, qint64 maxSize)
{
    Q_UNUSED(data)
    Q_UNUSED(maxSize)
    qWarning("UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::readData not supported");
    return -1;
}
qint64 UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::writeData(const char *data, qint64 maxSize)
{
    if(m_FirstCallToWriteData)
    {
        m_FirstCallToWriteData = false;
        m_Hasher.reset();

        //was called headerCommentAndPlaceholderIcanHOPEFULLYoverwriteJit_acknowledgingIamNotAllowedToRead, but that made it a lot harder to read:
        QByteArray cryptographicHashHeader(ModificationGuardHeaderPrefix);
        cryptographicHashHeader.append(DummyCryptographicHashForSizingPurposes);
        cryptographicHashHeader.append("\n");

        m_SaveFile->write(cryptographicHashHeader);
    }
    m_Hasher.addData(data, maxSize);
    return m_SaveFile->write(data, maxSize);
}
qint64 UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::myHeaderSize_InclNewline() const
{
    qint64 ret = ModificationGuardHeaderPrefix.size();
    ret += DummyCryptographicHashForSizingPurposes.size();
    ++ret; //for the newline
    return ret;
}
bool UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::myActualOpenForWriting()
{
    if(!m_SaveFile->open(QIODevice::WriteOnly | QIODevice::Truncate))
        return false;
    return QIODevice::open(QIODevice::WriteOnly | QIODevice::Truncate);
}
QByteArray UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::getHasherResultEncoded()
{
    //THIS METHOD decides toHex or toBase64 etc
    return m_Hasher.result().toBase64(QByteArray::KeepTrailingEquals /*we use this method for SIZING purposes, so we need to explicitly keep the trailing equals*/);
}
bool UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::fileContentsMatchCryptographicHash(QTextStream &t, const QByteArray &cryptographicHexHashToCheckAgainst)
{
    m_Hasher.reset();
    while(!t.atEnd())
    {
        //QString currentLine = t.readLine() + "\n"; //readLine takes the \n out, but we want to keep it in our hash calculation!
        static const int bufferSize = 4096;
        QString currentBuffer = t.read(bufferSize);
        m_Hasher.addData(currentBuffer.toUtf8());
    }
    QByteArray calculatedHash = getHasherResultEncoded();
    m_Hasher.reset();
    return (calculatedHash == cryptographicHexHashToCheckAgainst);
}
void UnmodifiedFileSafeOverwriter_ViaCryptographicHashHeaderVerification::myE(QString msg)
{
    emit e("QSaveFile error maybe: " + m_SaveFile->errorString());
    setErrorString(msg);
    emit e(msg);
}
