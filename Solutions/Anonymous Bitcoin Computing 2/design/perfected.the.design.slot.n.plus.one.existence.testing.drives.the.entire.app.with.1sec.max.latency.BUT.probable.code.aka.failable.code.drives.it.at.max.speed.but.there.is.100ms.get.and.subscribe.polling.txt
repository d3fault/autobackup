Get and subscribe via lazy polling with 100ms "max stale time" (if <= 100ms, give em cache) for the "campaign doc". Get and subscribing the campaign doc also subscribes the wt node (same "class" or "scope" that does the get and subscribe > 100ms check/fetch/cache-hit-return) to the associated "slotFillerN+1" in a custom-hack-yet-fucking-awesome "rand() % 10 == 0 ? checkToSeeIfSlotFillerN+1existsAsA_WORST_CASE_SCENARIO_CONSTANT_RECOVERY_MODE_AND_WHEN_ENGAGED_DOES_CAS_SWAP_UPDATING_CAMPAIGN_DOC(and user doc (unlock) if need be (incl debiting), and transaction doc which must be LCB_ADD'd (using specific slot name (incidentally a key!) cleverly in key choice) before the user-account is unlocked which i think mitigates that race conditon from login-recovery i was thinking of doing (and now know better)). So basically if we checktoSeIfSlotFillerN is there, we double check campaign doc to make sure we didn't just 'get lucky' (will happen quite often), THEN we simply do nothing for ANOTHER 100ms to give our neighbors who we could have 'gotten lucky' and beaten to getting the campaign doc before they could update it some more time (100ms is ample (yet low to human)), then we verify in this exact order: the transaction exists. whether or not it exists we then go to the user-account (with balance) and make sure that the "slotAboutToBuy" wasn't the one we are in the process of error recovering from. It could be empty which means the account is unlocked and all that means is that we need to make the transaction document (which may have even been added by the time we get around to it, so we are ok with our LCB_ADD failing with key exists). If the transaction document doens't exist and the user account is still locked to the slot we are attempting recovery from, then we try to LCB_ADD it just like before, but then regardless of whether we succeed with the LCB_ADD at this point we also try to unlock the user-account (this is actually overkill at this point (if we failed to get the LCB_ADD just mentioned), but it is safe to do so long as we CAS-swap-unlock it (and accept first failure (because any unlocking by neighbors will have finished the same transaction (and maybe started another, which is irrelevant) because there would be ~2 nodes trying to do the user-account-unlocked (one acting in '1-sec-max-recovery-mode-false-positives-ok' mode (the description of everything so far), as the false positive himself)). Of course if the user-account is locked to another slot and the transaction isn't made, we know the system has failed entirely and we coded it wrong. More likely than the last sentence, it wi

The campaign doc is of course updated after all of this succeeds, but in a manner that accepts CAS failure as well. I was tempted to write "if we are ok with CAS failure, then we should just use LCB_SET. but then we may have overwritten a FUTURE slot purchase and brought it back in time (unlikely, BUT POSSIBLE if network congestion)", therefore I do need to CAS input for the campaign doc (but remember, stop trying after first try fails (unless it's an error we should retry. stop only after first CAS fail)).

The 10 in the second sentence represents "number of nodes", and we do that random number genration once per second... thus giving us to (if we desire) cryptographically secure "distribution" amongst the 10. It doesn't matter if the number 0 isn't chosen and one second slips by where

Actually it makes more sense for them to all agree an an alternating schedule (it makes the software more scalable IN THE FUTURE (won't be evident just yet) to use cryptographic level-distribution for a pre-arranged alternating schedule that all participators agreed on. "Append" might be a helpful tool in keeping track of the schedule and participants, but i've just opened a whole can of worms with that design (simple but need to wrap my head around it completely i can tell (so, simple... just not yet ;-P). To KISS I can use the easy-shifting-by-ten planning, but try to make the planning part of it modular somehow.

It is not a big deal if no nodes are chosen randomly (though we can guarantee it using a schedule) if we just use a simple-UNCOORDINATED (yet still cryptographically distributed if we desire (YESSS THIS IS BEST WAY FUCK COORDINATING)). sha1("'rand()' + 'currentTimeString' + 'per-node-id'") and then sharding as much as needed (10 is easy) would give me good results. I'll try to say for the third time: if all 10 (n) nodes get lucky and choose to do the recovery process all at the same second by sheer chance, the system STILL functions fine and dandy. They can and need to all be able to do it together, perhaps by dumb luck a different machine doing each stage working fine too (knowing when a CAS fail is ok).


There is a way to scale what I have just described for a single "campaign" (series of slots (most important doc of which is the slot (which gets filled via LCB_ADD (after locking/declaring the buy in his user account))) to generic key usage, and in that way of looking at it where you have tons of them like that, it is effectively "journaling". In fact what you have just designed IS journaling. It is your system finally perfected. I fucking knew just hacking at it and meditating I'd perfect it. Ok actually I didn't but it doesn't surprise me.


If the user account is locked when we log in and the slot they wanted to buy is not theres, we recover by unlocking the account without debiting (cas may fail as user could be logged in somewhere else and doing just fine). We do not ever proceed forward with the buy when we detect at login that the user-account is locked. It is assumed that the "rand % 10 == 0" recovery 'possy'" will do that, but they will only do it if a given Wt machine (the one they are logged into) does the user-account-lock AND the slot fill at the immediate behest of the user. Getting only the user account doc and seeing it being locked on login, we _DO_ do a check for the slot he intended to fill, but if it's empty then we go into 1sec polling of the slot which is declared to be bought. We don't know who is going to win (BUT WE ARE INTERESTED) but we stay out of it because the user did not initiate it explicitly in this session (however if they do (would be AGAIN if thinking cross-session), then yea we go for it. We are interested in who is going to win because IF IT ISN'T US THAT ENDS UP WINNING, _WE_ are now responsible for cas-unlocking (can fail because neighbor 'login-recoveries' could be doing same process and just beat us, but doing it via cas is still crucial (like above)) the user-account [without debiting]. If as we monitor it we see that we did win, we back off / forget and don't do shit because the "rand % 10" possy will take care of the user-account-unlocking