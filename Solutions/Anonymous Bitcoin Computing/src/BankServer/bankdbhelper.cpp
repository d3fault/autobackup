#include "bankdbhelper.h"

BankDbHelper::BankDbHelper(QObject *parent) :
    QObject(parent), m_Db(0)
{
}
void BankDbHelper::init()
{
    //may need to refactor this for example if the db connect is async instead then i connect to a signal on CouchBaseClusterDbHelper to emit our initialized. won't know until fucking around with Couchbase. pretty sure it's synchronous though. in any case, i should focus on the message recycling in the network shit for now anyways. recycling seems pointless but considering this is hopefully the last time i'll ever have to do it (fuck yea Rpc Generator), it might be worth it.
    //TODOreq: in some domains recycling might be dumb. if there is a consistent flow of 5kb messages and then 1x 2mb one out of nowhere then back to normal, i'll have a 2mb message allocated and being recycled over and over for the 5kb messages. maybe i should have to specify a certain size? but even still QString grows as needed, and I don't want to manually manage teh bytes lawl.
    //for my bank examples i'll have relatively consistent message sizes so it is ok.
    //MAYBE (unsure), when i have a 200 character QString and then write/replace it with a 5 character QString, the 195 characters that were there return to be able to be allocated again? unsure and test this. TODOreq

    if(!m_Db)
    {
        m_Db = new CouchBaseClusterDbHelper();
        if(m_Db->connectAndShit())
            emit initialized();
    }
}
void BankDbHelper::createBankAccount(const QString &username)
{
    //pseudo-code
    CreateBankAccountRequest request; //comes in as arg, but just for simplicity i'm defining it here

    CreateBankAccountResponse response = request.getResponse();

    //then DO THE ACTUAL db shit...
    //and fill out the response depending on errors
    response.setCompleted();
    response.setFailedAddReason(????); // i do think in some cases there will be multiple failed reasons.. but in most we will stop once we detect only one...

    //so this class and RpcClientsHelper need to operate on the same object type, while still abstracting the protocol. also, i need to create a bank account in the correct sub-bank. Bank (all) -> Sub-Bank (per appDb) -> Sub-Bank-Account. never refer to 'Bank-Account' because it is ambiguious. I have previously referred to 'sub-bank-account' to mean 'sub-bank'. whoops.

    //why would/should BankDbHelper need to depend on a type that is generated by the Rpc Generator? this is bad design. or is it? Bank depends on it in that it implements it (the interface that is generated includes the ArgObjects and uses them in the virtual method signatures). And seeing as Bank depends on BankDb (or is it other way around?), I could maybe be ok with BankDb depending on those ArgObjects
    //but how would i include them and get them to be usable? by including the interface that Bank implements???????????????????????
    //they might already be accessible to me since Bank #include'd them, idfk. Bank is definitely set up before I am (or i can make it so)
    //idfk.
}
