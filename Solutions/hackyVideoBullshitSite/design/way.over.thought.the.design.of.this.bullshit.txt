Bleh been thinking way too hard on this stupid easy problem. Abc user (video blog) is a Wt app with a backend thread implementing a GetAndSubscribe for the image/url/hover. 30 seconds before "todays" ad expires, it does a boost::asio http get on a 'Wt global public resource' that is running on Abc server network (as I have it coded now, it would be a separate/synchronous app rarely run). The boost::asio http request has, say, 25 second timeout at which case it will decide to WServer::post a "no ad" aka placeholder image/url/hover. The WServer::post'ing is spaced out over a 5 minute interval to avoid a spike 'at the stroke of midnight'. For 10k viewers, we can WServer::post one viewer every .03 seconds (3 ms), which is easily dynamically calculated/scaling at run time. Unlike Abc2 actual's WServer::post which happens all-at-once/fast-as-possible, the WServer::post that we will be doing will be triggering binary image downloads to the server, so would cause a huge bandwidth spike (even though the server is ALREADY handling video streams for each user, that 'stroke of midnight' image spike might push us over the limit every time it's hit, if we're running at near-max already because of the video shit.

I had so many fail ideas about how to do it best, including using Wt::Http::Client to do it (BUT WHAT IF HE THE ASSOCIATED USER DISCONNECTS!?!? <-exactry, fuck dat shit)... but it needed shared/exclusive locking and blah all kinds of synchronization and fuck that shit.

Still need some sort of queue mechanism for the GetAndSubscribe requests (which will be much easier to manage this time around. no need to differentiate js/no-js, or change session ids. simply: construct -> subscribe, destruct -> unsubscribe), and what better time to try out lockfree::queue