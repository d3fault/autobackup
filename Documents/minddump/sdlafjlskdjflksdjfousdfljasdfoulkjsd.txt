A hacky as fuck, yet still functional, way to develop and migrate to QWidgets2 (hardware accelerated is main/only(?) difference (provided via Qt Quick/Scene Graph! It is imperitive that we use the same backend that QML uses so we get all future enhancements as well!)) is to basically just "try" to compile the source using the QWidgets2 module. We aim for 100% source compatibility (though how the system functions behind the scenes will differ drastically), and here comes the hacky part: whenever the compiler complains that certain aspects of the source don't exist (have yet to be ported), we simply re-compile with the QWidgets1 module. This can be completely transparent to the user, but they could also be provided a "force hardware accelerated GUI" checkbox where the compilation process stops when encountering those same errors, then spitting them out to the user.

Differentiating between actual source problems and qwidget2/1 problems is seamless because we'll his the actual source problems (developer/user errors) on the second "compile attempt" as well. If you properly separate your gui and business logic, you wouldn't even need to recompile the business ('actual source problems' from the developer) during the second round. The compiler/linker or whatever would see the already existing/unchanged .o files and just use them.


This way any app with a simple QWidget GUI (most of mine I feel are really damn simple (and I like them that way)) can gracefully degrade to software mode. QWidgets1 is still maintained and supported by Digia, so you don't even really have to worry about them at all.


On one hand I think that the technical requirements for doing this are infeasible: too much code in existing apps is run in the main/gui thread.... but then I remember that QML/QtQuick have the same problem: the JavaScript is too! Fucking idiots think interpreted is going to be faster/OK to run in main/gui thread and C++/native is not? It is the opposite! If there's any code you want to be running in the main/GUI thread, it's going to be the [significantly] faster one (to minimize GUI lockups). This of course ignoring the whole "long standing operations should be in backend". There's a gray area / hard-to-find-line between "eh short enough that you should put it in the main/gui thread" (because it is SO FAST that the user won't notice (and putting it in a backend thread will cause a noticeable slowdown (because of a single or multiple context switches)) and "long enough running 'functionality'/function-calls-etc" to warrant a separate backend thread. Identifying that line is difficult, but the fact is that most function calls are better off in the main thread. I tend to code opposite of that fact and am starting to realize it (I tend to do EVERYTHING in a backend thread). OT but w/e