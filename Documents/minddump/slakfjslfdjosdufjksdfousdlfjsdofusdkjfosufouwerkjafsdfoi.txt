The context switch divide. On context switch, we are essentially always attempting to persist until we have synchronized. So the "context switch divide" is implemented by having an ON-GUI-THREAD "cache" (say, of recently typed keys in a notepad application) that is periodically "flushed" after either a certain amount of characters or a certain amount of time. i would say one sentence is the common/default(?) threshold if you type a reasonably low amount of characters and under a reasonably low amount of time. Since we are not giving the cpu REASON to go to our business thread, it remains idle until we know we have a "reasonable amount of data" to persist. we DO make compromises on the size of what is "reasonable" when a timer of no keys pressed after typing a bit and then stopping, or perhaps even additionally we could have a minimum amount of characters ignoring the every sentence we context switch rule filter/thingo, in order to handle the small sentences case more efficiently. actually we shouldn't do that because then you don't get as much of a guarantee and/or satisfaction when you press a period (or semicolon in coding environment (also open parenthesis/curly-bracket)).

This seems like nothing more than a really effective optimization. "sync" (linux) doesn't need to be done all the time or even during a definite timeout... but when a USER is USING the computer, sync SHOULD be used at somewhat large intervals (length-to-type-sentence is a reasonably long interval to be running "sync" at. long enough to not slow down the asynchronous efficiency gains that warrant the sync call to begin with. the human experience demands "sync" calls... but the computer when not interacting with a human can/should always be asynchronous in nature.


how i'll handle elpsis (when to sync):
so basically trailing dots would get a sync point of "when i am done pressing a trail of dots". so "space" in that above case would cause me to NOT sync because oh shit that is the ellipses exception case that i am about to document.
BUT HOWEVER when there is four or more dots then the dots are simply put on the end of another sync point. except that is impossible because we sync right when the first period is pressed. the remaining dots when there is exactly 3 (the ellipses exception) are put into the following sync-unit-of-cache(what we cache in the GUI thread/object (the timeout has to be universally re-usable/customizable to all kinds of use cases)).
so i guess if there's 3 or less than 3 periods then all of them just go into the second sync unit. 4 or more and the periods all get their own. once we are in the period mode then we can also allow random fucking characters in a row without syncing ever until we type space or until a timeout of some reasonable length (10 seconds?) 10 seconds actually seems like a great sync rate for a human being interacting with a computer. 10 seconds or a sentence. fuck that small sentence optimization. But also: 10 seconds or a space (when in character mode). 3 or less dots for example can leave you in text mode! it is an exception to the "characters mode (which syncs at space character only (and perhaps a minimum amount of time must elapse?))