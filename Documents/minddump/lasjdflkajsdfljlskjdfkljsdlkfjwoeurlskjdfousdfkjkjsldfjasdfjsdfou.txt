if(!airGap)
	hackable = true;

//note: even with an airgap, you're still susceptible (sp?) to vulnerabilities in any parsed file [transferred via thumb drive] or even a vulnerability in the partition/filesystem drivers themselves. i've designed but not finished designing (and haven't started implementing at all) an airgap solution using video+qrcode, where the storage "input only box" does not parse the data received as qr (except perhaps for parity/authentication, but that would then be a vector of attack should you muck up the coding (saving the qrcode as an image without even decoding it is safest)). that same "input only box" could/should also output the same stream of qrcode to another box that is more of a "executer... not safe from fault BUT is not the master holder of data anyways"... but really there's no point of going THROUGH the input only box and back out (except to "know" that you've received it (actually that's a good reason. "executer" does parity/authentication and can request a specific chunk be re-sent through the video+qrcode over and over until the copy that "executer" sees authenticates (which should mean that the "input only box" copy also authenticates (but since there are TWO lossy conversions, there's a SLIGHT/miniscule chance that the input only box doesn't authenticate (if processed digitally (if after burning to a cd-r, for example)) and the "executer" box does. it would be a weird bug indeed, where converting to analog the second time accidentally improves the quality of the qrcode stream enough to now authenticate. lol))