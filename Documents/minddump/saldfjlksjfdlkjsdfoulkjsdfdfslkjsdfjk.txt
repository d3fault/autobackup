Ok fine, you want me to tackle code? Bah, the problem I face is yet unsolved. It is the same problem kernel developers have yet to solve: the problem of the hanging application. The only solution seen is a timeout where the OS says "The application 'x' isn't responding. Do you wish to terminate it?". This is the exact same problem that I face with my Rpc Generator for requests that are "hanging in the business". Just as the kernel can't control the userland applications, My Rpc Generator cannot control the business's server functions/methods/actions. Solving this problem boggles my mind. I think of a retracable and retractable / "step-backwards/out" design that involves some sort of db layer (and already hate the idea from that point forward but eh), but really implementing even that in a usable manner still depends entirely on each and every business action!!! There's no way to guarantee that their code utilizes the "step out" concept properly! The problem still exists!!!!!!

Timelines. Write Ahead Logs. Journals. Whatever the fuck you want to call them.

They are possible but only applicable in a constrained target. Filesystem writes are constrained: nobody writes variant "write-to-fs" calls in userland. If every userland were responsible for reimplementing fs writes, WAL/Journaling would be impossible and/or much more difficult (dependent on each app).

How can I.... or can I... abstract the concept of "write-to-fs" so that I only have to code it once and then each and every Action only depends on it? My mind is collapsing and exploding on myself and I think this is a dead end... even though it's the closest I've ever gotten to summoning an answer.

I guess the question I should be asking is what the purpose of an action is. If the only purpose of an action is to modify some db values, then it is surely possible!!!!!!!!!

BUT, that is so limited in functionality that it's just bullshit.

I ask myself questions which tend to be stupid. My mind treads recklessly throughout studied programming domains.... unknowingly. This is why I need to launch and have some sort of collaboration: I need people to tell me when I'm being stupid. I need them to tell me when there is a "duh" and solved problem right in front of me that I'm just not seeing. Collaboration and the internet go hand and hand. People will probably do it just for the publicity (since I am harnessing "celebrity" etc).


Bah, back to the point motherfucker. What should I do about pending-in-business-Actions? Double back and wait twice as long, sure.... but then what? Shut down the entire fucking system like I said? Since I can't think of anything else [for now], I guess yes. TODOreq perhaps a "noncritical" vs. "critical" flag for each action can be set. For example, a forum post or an article comment failing is NOT CRITICAL... whereas a bitcoin transaction and/or ad slot filler purchase......... is. It depends entirely on the Action whether it is critical.... so I can set a flag to let my system know what to do should a request get lost in the business.


I feel like even if there is a way to abstract "write-to-fs"'ing, that it shouldn't or can't be done in Rpc Generator itself. It needs to be done in a higher level class that encapsulates/abstracts Rpc Generator itself. A level of design that has and knows about database operations. As for Rpc Generator, maybe it just does what it does and reports what is going on -- not worrying about the end result. Oh it's lost? Here we detected it's lost now YOU decide what the fuck to do with that fact. Maybe it goes ignored or maybe we roll back and try on another business (assuming that would even give us remote confidence in it succeeding on another one). I don't fucking know. I just know I need to design the clean/ugly disconnect use cases and from there I will be able to derive the "merge connection" design -- I hope. I guess I'll just stick with "reporting" lost in business for now.... and try to solve it later! But I'll probably never have success for the same reason that Kernel devs still haven't had success: unsolvable problem is unsolvable. Nothing stops an idiot from typing "while(true) {}" in their business (or userland).