I crawl through space and time (inchworm) in an abstract void of infinite possibilities enabled by my computer and especially it's compiler and especially it's toolkit. I think of buttons to push, make them, then push them. That is one inchworm (which I earlier mis-typed as inchwork) crawl cycle.


Inchwork: A gui that let's you create a template app for a button that has it's name "what it does" pre-filled in. It also has the backend template generated and a convenient "//Type/Code here" comment starting point. After the backend (coded as lib ofc, the button is to help OTHER people become coders, not for me directly (but could be I guess?)) compiles, the button becomes pushable. It needn't do anything, but it can emit xFinished(bool success, Args...). or perhaps we use RequestResponseContracts, so in that case it just says that it fails by default over and over each time you click it. so maybe the "//Type/Code here" must be above some generated "response->setSuccess(true);" template code-- wait no that would ruin the use of RequestResponseContracts completely. pushing the button must fail to default (err I mean to say default to fail, but too late to change it :)) in order for RequestResponseContracts to have any use.

So initial gui of inchwork is just a list of buttons that you can independently select and click. Buttons which have already been proven to be in compiling state. A simple list widget is perfect. A gui in the future could chain button-actions together into a single click. Let's not get too far ahead of ourselves.